<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Ball Rolling Game</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; }
    canvas { display: block; }
    #hud {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      background: rgba(0,0,0,0.5);
      padding: 8px 10px;
      border-radius: 8px;
      user-select:none;
      line-height: 1.3;
    }
    #menu {
      position: absolute;
      inset: 0;
      display: flex; align-items: center; justify-content: center; flex-direction: column;
      background: rgba(0,0,0,0.8);
      color: white; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      z-index: 10;
    }
    button { margin-top: 12px; padding: 10px 20px; font-size: 16px; border-radius: 6px; border: none; cursor: pointer; }
  </style>
</head>
<body>
  <div id="hud">Moves: 0 | Time: 0s<br>Best Moves: - | Best Time: -</div>
  <div id="menu"><h1>Ball Rolling Game</h1><button data-action="start">Start Game</button></div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
  <script>
  (() => {
    const TILE_SIZE = 1;
    const TILE_HEIGHT = 0.1;
    const BALL_RADIUS = 0.3;

    const MOVE_SPEED = 3; // Ball speed in tiles per second
    const CAM_SMOOTH = 0.12;
    const LIFT_SPEED = 2.0;
    const LIFT_PAUSE_MS = 2000;
    const DROP_DURATION = 200;
    const LAND_DURATION = 200;

    const DEFAULT_CAM = {
      yaw: Math.PI, // * 0.75, // + , // - Math.PI/4, // - Math.PI/4,
      pitch: 0.35,
      dist: 6
    };

    const levels = [
    {
      "elements": [
        {"type":"floor","from":{"x":0,"y":0,"z":0},"to":{"x":15,"y":0,"z":15}},
        {"type":"start","position":{"x":-1,"y":0,"z":0}},
        {"type":"floor","position":{"x":-1,"y":0,"z":15}},
        {"type":"floor","position":{"x":0,"y":0,"z":-1}},
        {"type":"floor","position":{"x":15,"y":0,"z":-1}},
        {"type":"goal","position":{"x":15,"y":0,"z":15}},
        {"type":"lift","from":{"x":-1,"y":0,"z":1},"to":{"x":-1,"y":0,"z":14}},
        {"type":"lift","from":{"x":1,"y":0,"z":-1},"to":{"x":7,"y":0,"z":-1}},
        {"type":"lift","from":{"x":-1,"y":0,"z":-1},"to":{"x":15,"y":15,"z":15}},
        {"type":"lift","from":{"x":-2,"y":0,"z":0},"to":{"x":-2,"y":-15,"z":0}},
        {"type":"teleporter","entry1":{"x":2,"y":0,"z":2},"entry2":{"x":13,"y":0,"z":13}},
        {"type":"stair","position":{"x":14,"y":1,"z":14},"direction":"right","count":"6"},
        {"type":"floor","position":{"x":0,"y":0,"z":-2}},
        {"type":"stair","position":{"x":1,"y":0,"z":-2},"direction":"right","count":"6"},
        {"type":"bonuscrystall","position":{"x":8,"y":3,"z":9}},
        {"type":"bonuscrystall","position":{"x":8,"y":3,"z":7}}
      ]
    },
    {
      "elements": [
        {"type":"floor","from":{"x":0,"y":0,"z":0},"to":{"x":5,"y":0,"z":5}},
        {"type":"start","position":{"x":-1,"y":0,"z":0}},
        {"type":"goal","position":{"x":5,"y":0,"z":5}}
      ]
    }
  ];
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const loader = new THREE.CubeTextureLoader();
    const skybox = loader.load([
      './bg/bg_front.bmp',
      './bg/bg_back.bmp',
      './bg/bg_top.bmp',
      './bg/bg_bottom.bmp',
      './bg/bg_right.bmp',
      './bg/bg_left.bmp'
    ]);
    scene.background = skybox;

    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(5, 10, 5);
    scene.add(dirLight);

    const tileGeo = new THREE.BoxGeometry(TILE_SIZE, TILE_HEIGHT, TILE_SIZE);
    const ballGeo = new THREE.SphereGeometry(BALL_RADIUS, 32, 32);

    const tileMat  = new THREE.MeshStandardMaterial({ color: 0x444444 });
    const startMat = new THREE.MeshStandardMaterial({ color: 0x2255ff });
    const goalMat  = new THREE.MeshStandardMaterial({ color: 0x22ff55 });
    const liftMat  = new THREE.MeshStandardMaterial({ color: 0xffff00 });
    const ballMat  = new THREE.MeshStandardMaterial({ color: 0xff2222 });

    let tiles = [];
    let lifts = [];
    let teleporters = [];
    let crystals = [];
    let crystalsRemaining = 0;
    let goalActive = false;
    let startTile, goalTile;
    let START_POS, GOAL_POS;

    const ball = new THREE.Mesh(ballGeo, ballMat);
    scene.add(ball);

    class Lift {
      constructor(x1,y1,z1,x2,y2,z2) {
        this.start = new THREE.Vector3(x1,y1,z1);
        this.end   = new THREE.Vector3(x2,y2,z2);
        this.progress = 0;
        this.forward = true;
        this.waitUntil = 0;
        this.distance = this.start.distanceTo(this.end);
        this.travelTime = Math.max(0.0001, this.distance / LIFT_SPEED);
        this.mesh = new THREE.Mesh(tileGeo, liftMat);
        scene.add(this.mesh);
        this.mesh.position.copy(this.start);
      }
      update(dtMs) {
        if (Date.now() < this.waitUntil) return;
        const delta = dtMs / (this.travelTime * 1000);
        this.progress += this.forward ? delta : -delta;
        if (this.progress >= 1) { this.progress = 1; this.forward = false; this.waitUntil = Date.now() + LIFT_PAUSE_MS; }
        if (this.progress <= 0) { this.progress = 0; this.forward = true;  this.waitUntil = Date.now() + LIFT_PAUSE_MS; }
        this.mesh.position.lerpVectors(this.start, this.end, this.progress);
      }
      reset() { this.progress = 0; this.forward = true; this.waitUntil = 0; this.mesh.position.copy(this.start); }
      dispose() { scene.remove(this.mesh); }
    }

    class Teleporter {
      constructor(e1, e2) {
        this.entry1 = new THREE.Vector3(e1.x, e1.y/3, e1.z);
        this.entry2 = new THREE.Vector3(e2.x, e2.y/3, e2.z);
        this.mesh1 = new THREE.Mesh(tileGeo, new THREE.MeshStandardMaterial({ color: 0xff00ff }));
        this.mesh2 = new THREE.Mesh(tileGeo, new THREE.MeshStandardMaterial({ color: 0xff00ff }));
        this.mesh1.position.set(e1.x, e1.y/3-TILE_HEIGHT/2, e1.z);
        this.mesh2.position.set(e2.x, e2.y/3-TILE_HEIGHT/2, e2.z);
        scene.add(this.mesh1);
        scene.add(this.mesh2);
      }
      checkTeleport(pos) {
        if (Math.abs(pos.x - this.entry1.x) < 0.1 && this.entry1.distanceTo(pos) < 0.5 && Math.abs(pos.z - this.entry1.z) < 0.1) {
          pos.copy(this.entry2);
        } else if (Math.abs(pos.x - this.entry2.x) < 0.1 && this.entry2.distanceTo(pos) < 0.5 && Math.abs(pos.z - this.entry2.z) < 0.1) {
          pos.copy(this.entry1);
        }
      }
      dispose() {
        scene.remove(this.mesh1);
        scene.remove(this.mesh2);
      }
    }

    class BonusCrystall {
      constructor(pos) {
        this.pos = new THREE.Vector3(pos.x, pos.y/3*BALL_RADIUS, pos.z);
        const geo = new THREE.OctahedronGeometry(0.3);
        const mat = new THREE.MeshStandardMaterial({ color: 0x00ffff, emissive: 0x00ffff, emissiveIntensity: 0.6 });
        this.mesh = new THREE.Mesh(geo, mat);
        this.mesh.position.set(pos.x, pos.y/3*BALL_RADIUS, pos.z);
        scene.add(this.mesh);
        this.collected = false;
      }
      checkCollect(ballPos) {
        if (!this.collected && ballPos.distanceTo(this.pos) < 0.5) {
          this.collected = true;
          scene.remove(this.mesh);
          crystalsRemaining--;
          if (crystalsRemaining <= 0) {
            goalTile.material = new THREE.MeshStandardMaterial({ color: 0x22ff55, emissive: 0x22ff55, emissiveIntensity: 0.8 });
            goalActive = true;
          }
        }
      }
      dispose() { scene.remove(this.mesh); }
    }


    function loadLevel(index) {
      tiles.forEach(t => scene.remove(t));
      lifts.forEach(l => l.dispose && l.dispose());
      teleporters.forEach(t => t.dispose());
      crystals.forEach(c => c.dispose());
      if (startTile) scene.remove(startTile);
      if (goalTile)  scene.remove(goalTile);
      tiles = [];
      lifts = [];
      teleporters = [];
      crystals = [];
      crystalsRemaining = 0;
      goalActive = false;
      startTile = goalTile = undefined;
      START_POS = GOAL_POS = undefined;

      const def = levels[index].elements;
      def.forEach(obj => {
        if (obj.type === "floor") {
          if (obj.from && obj.to) {
            const minX = Math.min(obj.from.x, obj.to.x);
            const maxX = Math.max(obj.from.x, obj.to.x);
            const minY = Math.min(obj.from.y, obj.to.y);
            const minZ = Math.min(obj.from.z, obj.to.z);
            const maxZ = Math.max(obj.from.z, obj.to.z);

            for (let x = minX; x <= maxX; x++) {
              for (let z = minZ; z <= maxZ; z++) {
                const t = new THREE.Mesh(tileGeo, tileMat);
                t.position.set(x, minY/3-TILE_HEIGHT/2, z);
                scene.add(t); tiles.push(t);
              }
            }
          } else {
            const t = new THREE.Mesh(tileGeo, tileMat);
            t.position.set(obj.position.x, obj.position.y/3-TILE_HEIGHT/2, obj.position.z);
            scene.add(t); tiles.push(t);
          }
        } else if (obj.type === "start") {
          startTile = new THREE.Mesh(tileGeo, startMat);
          startTile.position.set(obj.position.x, obj.position.y/3-TILE_HEIGHT/2, obj.position.z);
          scene.add(startTile); tiles.push(startTile);
          START_POS = new THREE.Vector3(obj.position.x, obj.position.y/3, obj.position.z);
        } else if (obj.type === "goal") {
          //goalTile = new THREE.Mesh(tileGeo, goalMat);
          goalTile = new THREE.Mesh(tileGeo, new THREE.MeshStandardMaterial({ color: 0x003300 })); // dark until activated
          goalTile.position.set(obj.position.x, obj.position.y/3-TILE_HEIGHT/2, obj.position.z);
          scene.add(goalTile); tiles.push(goalTile);
          GOAL_POS = new THREE.Vector3(obj.position.x, obj.position.y/3, obj.position.z);
          goalActive = false;
        } else if (obj.type === "lift") {
          const l = new Lift(obj.from.x, obj.from.y, obj.from.z, obj.to.x, obj.to.y, obj.to.z);
          lifts.push(l);
        } else if (obj.type === "teleporter") {
          const t = new Teleporter(obj.entry1, obj.entry2);
          teleporters.push(t);
        } else if (obj.type === "bonuscrystall") {
          const c = new BonusCrystall(obj.position);
          crystals.push(c);
          crystalsRemaining++;
        } else if (obj.type === "stair") {
          const dirMap = {
            "right": new THREE.Vector3(1, 0, 0),
            "left":  new THREE.Vector3(-1, 0, 0),
            "forward": new THREE.Vector3(0, 0, 1),
            "back": new THREE.Vector3(0, 0, -1)
          };
          const dir = dirMap[obj.direction] || new THREE.Vector3(1,0,0);
          const steps = parseInt(obj.count) || 1;
          for (let i = 0; i < steps; i++) {
            const t = new THREE.Mesh(tileGeo, tileMat);
            const pos = new THREE.Vector3(
              obj.position.x + dir.x * i,
              (obj.position.y + i) * 1/3,   // 👈 Y increases 1/3 per step
              obj.position.z + dir.z * i
            );
            t.position.set(pos.x, pos.y - TILE_HEIGHT/2, pos.z);
            scene.add(t);
            tiles.push(t);
          }
        } else {
          if (obj.position) {
            const t = new THREE.Mesh(tileGeo, tileMat);
            t.position.set(obj.position.x, obj.position.y/3-TILE_HEIGHT/2, obj.position.z);
            scene.add(t); tiles.push(t);
          }
        }
      });

      resetGame();
    }

    const hud  = document.getElementById('hud');
    const menu = document.getElementById('menu');

    let ballPos = new THREE.Vector3();
    let moves = 0, startTime = 0, timerId;
    let bestMoves = null, bestTime = null;

    let velocityY = 0, falling = false, isMoving = false;
    let moveFrom = new THREE.Vector3(), moveTo = new THREE.Vector3();
    let moveStartTime = 0, moveDuration = 0.5 / MOVE_SPEED;
    let ridingLift = null;

    let dropStartY = null, dropStartTime = null;
    let landStartY = null, landTargetY = null, landStartTime = null;

    let gameRunning = false;
    let currentLevel = 0;

    function updateHUD() {
      const t = Math.max(0, Math.floor((Date.now() - startTime) / 1000));
      hud.innerHTML = `Moves: ${moves} | Time: ${t}s<br>Best Moves: ${bestMoves ?? '-'} | Best Time: ${bestTime ?? '-'}`;
    }

    function resetGame() {
      ballPos.copy(START_POS);
      ball.position.copy(ballPos);
      ball.rotation.set(0,0,0);
      velocityY = 0; falling = false; isMoving = false; moves = 0;
      dropStartY = null; landStartY = null;
      lifts.forEach(l => l.reset());
      gameRunning = false;
      startTime = Date.now();
      updateHUD();
    }

    function loseGame() {
      clearInterval(timerId);
      isMoving = false;
      falling = false;
      menu.style.display = 'flex';
      menu.innerHTML = `<h1>You Fell!</h1><button data-action="restart">Restart Level</button>`;
    }

    function winGame() {
      clearInterval(timerId);
      const duration = Math.floor((Date.now() - startTime) / 1000);
      if (!bestTime || duration < bestTime) bestTime = duration;
      if (!bestMoves || moves < bestMoves) bestMoves = moves;
      localStorage.setItem('bestTime', bestTime);
      localStorage.setItem('bestMoves', bestMoves);
      currentLevel++;
      if (currentLevel < levels.length) {
        startLevel(currentLevel);
      } else {
        menu.style.display = 'flex';
        menu.innerHTML = `<h1>You Win All Levels!</h1><button data-action="restart">Restart Last Level</button>`;
        currentLevel = levels.length - 1;
      }
    }

    function startLevel(index) {
      loadLevel(index);
      clearInterval(timerId);
      timerId = setInterval(updateHUD, 1000);
      setTimeout(() => { gameRunning = true; }, 2000);
    }

    function restartLevel() { startLevel(currentLevel); }

    menu.addEventListener('click', (e) => {
      const btn = e.target.closest('button');
      if (!btn) return;
      const action = btn.getAttribute('data-action');
      if (action === 'start') {
        e.preventDefault();
        menu.style.display = 'none';
        currentLevel = 0;
        startLevel(currentLevel);
      } else if (action === 'restart') {
        e.preventDefault();
        menu.style.display = 'none';
        startLevel(currentLevel);
      }
    });

    let camYaw = DEFAULT_CAM.yaw;
    let camPitch = DEFAULT_CAM.pitch;
    let camYawTarget = camYaw;
    let camPitchTarget = camPitch;
    let camDist = DEFAULT_CAM.dist;
    let camDistTarget = camDist;

    window.addEventListener('keydown', (e) => {
      camYawTarget = DEFAULT_CAM.yaw;
      camPitchTarget = DEFAULT_CAM.pitch;
      camDistTarget = DEFAULT_CAM.dist;
      if (!['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)) return;
      e.preventDefault();
      if (isMoving || falling) return;
      ridingLift = null; dropStartY = null; landStartY = null;
      const dir = new THREE.Vector3();
      if (e.key === 'ArrowUp')    dir.set(1, 0, 0);
      if (e.key === 'ArrowDown')  dir.set(-1,0, 0);
      if (e.key === 'ArrowLeft')  dir.set(0, 0,-1);
      if (e.key === 'ArrowRight') dir.set(0, 0, 1);
      moveFrom.copy(ballPos);
      moveTo.copy(ballPos).add(dir);

      // 🔹 NEW: check if target tile is higher (stairs or elevation)
      for (const t of tiles) {
        if (Math.abs(t.position.x - moveTo.x) < 0.1 &&
            Math.abs(t.position.z - moveTo.z) < 0.1) {
          const tileY = t.position.y;
          console.log("Current Y: ", moveFrom.y, `, tile pos: ${JSON.stringify(t.position)}`)
          if (tileY > moveFrom.y) {
            moveTo.y = tileY + BALL_RADIUS;
          }
        }
      }
      console.log("New Y: ", moveTo.y)
      // if moveTo location has teleporter presert, then teleport another entry
      for (const tele of teleporters) {
        tele.checkTeleport(moveTo);
      }
      window.__moveAxis = new THREE.Vector3(dir.z, 0, -dir.x).normalize();
      moveStartTime = performance.now();
      isMoving = true;
      moves++;
    });

    let dragging = false, lastX = 0, lastY = 0;
    window.addEventListener('mousedown', e => { dragging = true; lastX = e.clientX; lastY = e.clientY; });
    window.addEventListener('mouseup',   () => { dragging = false; });
    window.addEventListener('mousemove', e => {
      if (!dragging) return;
      const dx = e.clientX - lastX, dy = e.clientY - lastY;
      lastX = e.clientX; lastY = e.clientY;
      camYawTarget   += dx * 0.003;
      camPitchTarget += dy * 0.003;
      camPitchTarget = Math.max(-0.9, Math.min(0.9, camPitchTarget));
    });
    window.addEventListener('wheel', e => {
      camDistTarget += (e.deltaY > 0 ? 1 : -1) * 0.6;
      camDistTarget = Math.max(3, Math.min(12, camDistTarget));
    }, { passive: true });

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    function hasFloorBelow(x, y, z) {
      return tiles.find(t => Math.abs(t.position.x - x) < 0.1 && ((y+1) > t.position.y) && Math.abs(t.position.z - z) < 0.1);
    }
    /*
    return tiles.some(t => {
      if (Math.abs(t.position.x - x) < 0.1 && Math.abs(t.position.z - z) < 0.1) {
        console.log(`Ball at (${x},${y},${z}), Tile at (${t.position.x},${t.position.y},${t.position.z}), result is ${t.position.y - y}, tile y ${t.position.y}, ball y ${y}`);
        console.log(`condition: ${(y+1) > t.position.y}, ball y ${y}, tile y ${t.position.y}`);
      }
      return Math.abs(t.position.x - x) < 0.1 && ((y+1) > t.position.y) && Math.abs(t.position.z - z) < 0.1
    });
    */

    let lastTime = performance.now();
    function animate() {
      requestAnimationFrame(animate);
      const now = performance.now();
      const dt = now - lastTime;
      lastTime = now;

      if (gameRunning) { for (const l of lifts) l.update(dt); }

      if (isMoving && !falling) {
        const t = Math.min(1, (now - moveStartTime) / ( (0.5 / MOVE_SPEED) * 1000 ));
        ballPos.lerpVectors(moveFrom, moveTo, t);
        console.log(`468 Ball moved to ${ballPos.x}, ${ballPos.y}, ${ballPos.z}`);
        for (const lift of lifts) {
          if (Math.abs(lift.mesh.position.x - ballPos.x) < 0.1 &&
              Math.abs(lift.mesh.position.z - ballPos.z) < 0.1) {
            ballPos.set(lift.mesh.position.x, lift.mesh.position.y + BALL_RADIUS, lift.mesh.position.z);
            ridingLift = lift;
          }
        }
        const dist = TILE_SIZE * t;
        const angle = dist / BALL_RADIUS;
        ball.rotation.set(0,0,0);
        ball.rotateOnWorldAxis(window.__moveAxis || new THREE.Vector3(0,0,0), angle);
        if (t >= 1) {
          isMoving = false;
          ballPos.copy(moveTo);
          console.log(`483 Ball moved to ${ballPos.x}, ${ballPos.y}, ${ballPos.z}`);

          // collect crystals
          for (const c of crystals) c.checkCollect(ballPos);

          ridingLift = null;
          for (const lift of lifts) {
            if (Math.abs(lift.mesh.position.x - ballPos.x) < 0.1 &&
                Math.abs(lift.mesh.position.z - ballPos.z) < 0.1) {
              ridingLift = lift;
              dropStartY = null;
              landStartY = ballPos.y;
              landTargetY = lift.mesh.position.y + BALL_RADIUS;
              landStartTime = performance.now();
              break;
            }
          }
          if (!ridingLift) {
            // Check if we can drop onto a floor tile, from upwards lift
            const tx = Math.round(ballPos.x), ty = Math.round(ballPos.y), tz = Math.round(ballPos.z);
            const belowTile = hasFloorBelow(tx, ty, tz);
            if (belowTile) {
              ballPos.x = tx; ballPos.z = tz;
              dropStartY = belowTile.position.y + BALL_RADIUS;
              dropStartTime = performance.now();
              falling = false;
            } else {
              falling = true; velocityY = 0;
            }
          }
          if (goalActive && ballPos.distanceTo(GOAL_POS) < 0.5) { //ballPos.x === GOAL_POS.x && ballPos.z === GOAL_POS.z) {
            winGame();
          }
        }
      }

      if (falling) {
        velocityY -= 0.015;
        ballPos.y += velocityY;
        if (ballPos.y < -5) loseGame();
      } else if (!isMoving) {
        if (ridingLift) {
          if (landStartY !== null) {
            const elapsed = performance.now() - landStartTime;
            const t = Math.min(1, elapsed / LAND_DURATION);
            ballPos.y = landStartY + (landTargetY - landStartY) * t;
            ballPos.x = ridingLift.mesh.position.x;
            ballPos.z = ridingLift.mesh.position.z;
            if (t >= 1) landStartY = null;
          } else {
            ballPos.set(ridingLift.mesh.position.x,
                        ridingLift.mesh.position.y + BALL_RADIUS,
                        ridingLift.mesh.position.z);
          }
          dropStartY = null;
        } else {
          if (dropStartY === null) { dropStartY = ballPos.y + BALL_RADIUS; dropStartTime = performance.now(); }
          const elapsed = performance.now() - dropStartTime;
          const t = Math.min(1, elapsed / DROP_DURATION);
          ballPos.y = dropStartY;   // 👈 This pulls Y down to BALL_RADIUS
          ballPos.x = Math.round(ballPos.x);
          ballPos.z = Math.round(ballPos.z);
        }
      }

      ball.position.copy(ballPos);
      camYaw += (camYawTarget - camYaw) * CAM_SMOOTH;
      camPitch += (camPitchTarget - camPitch) * CAM_SMOOTH;
      camDist += (camDistTarget - camDist) * CAM_SMOOTH;
      const cx = ballPos.x + Math.cos(camYaw) * Math.cos(camPitch) * camDist;
      const cy = ballPos.y + Math.sin(camPitch) * camDist + 1;
      const cz = ballPos.z + Math.sin(camYaw) * Math.cos(camPitch) * camDist;
      camera.position.set(cx, cy, cz);
      camera.lookAt(ballPos.x, ballPos.y, ballPos.z);

      renderer.render(scene, camera);
    }
    animate();

  })();
  </script>
</body>
</html>
