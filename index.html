<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Ball Rolling Game</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; }
    canvas { display: block; }
    #hud {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      background: rgba(0,0,0,0.5);
      padding: 8px 10px;
      border-radius: 8px;
      user-select:none;
      line-height: 1.3;
    }
    #menu {
      position: absolute;
      inset: 0;
      display: flex; align-items: center; justify-content: center; flex-direction: column;
      background: rgba(0,0,0,0.8);
      color: white; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      z-index: 10;
    }
    button { margin-top: 12px; padding: 10px 20px; font-size: 16px; border-radius: 6px; border: none; cursor: pointer; }
  </style>
</head>
<body>
  <div id="hud">Moves: 0 | Time: 0s<br>Best Moves: - | Best Time: -</div>
  <div id="menu"><h1>Ball Rolling Game</h1><button data-action="start">Start Game</button></div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
  <script>
  (() => {
    const TILE_SIZE = 1;
    const TILE_HEIGHT = 0.1;
    const BALL_RADIUS = 0.3;
    const BALL_Y = 0 + BALL_RADIUS;

    const MOVE_SPEED = 1;
    const CAM_SMOOTH = 0.12;
    const LIFT_SPEED = 2.0;
    const LIFT_PAUSE_MS = 2000;
    const DROP_DURATION = 200;
    const LAND_DURATION = 200;

    const DEFAULT_CAM = {
      yaw: Math.PI, // * 0.75, // + , // - Math.PI/4, // - Math.PI/4,
      pitch: 0.35,
      dist: 6
    };

    const levels = [
      {
        "level": [
          {"type":"floor","from":{"x":0,"y":0,"z":0},"to":{"x":15,"y":0,"z":15}},
          {"type":"start","position":{"x":-1,"y":0,"z":0}},
          {"type":"floor","position":{"x":-1,"y":0,"z":15}},
          {"type":"floor","position":{"x":0,"y":0,"z":-1}},
          {"type":"floor","position":{"x":15,"y":0,"z":-1}},
          {"type":"goal","position":{"x":15,"y":0,"z":15}},
          {"type":"lift","from":{"x":-1,"y":0,"z":1},"to":{"x":-1,"y":0,"z":14}},
          {"type":"lift","from":{"x":1,"y":0,"z":-1},"to":{"x":7,"y":0,"z":-1}},
          {"type":"lift","from":{"x":-1,"y":0,"z":-1},"to":{"x":15,"y":15,"z":15}},
          {"type":"lift","from":{"x":-2,"y":0,"z":0},"to":{"x":-2,"y":-15,"z":0}}
        ]
      },
      {
        "level": [
          {"type":"floor","from":{"x":0,"y":0,"z":0},"to":{"x":5,"y":0,"z":5}},
          {"type":"start","position":{"x":-1,"y":0,"z":0}},
          {"type":"goal","position":{"x":5,"y":0,"z":5}}
        ]
      }
    ];

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const loader = new THREE.CubeTextureLoader();
    const skybox = loader.load([
      './bg/bg_front.bmp',
      './bg/bg_back.bmp',
      './bg/bg_top.bmp',
      './bg/bg_bottom.bmp',
      './bg/bg_right.bmp',
      './bg/bg_left.bmp'
    ]);
    scene.background = skybox;

    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(5, 10, 5);
    scene.add(dirLight);

    const tileGeo = new THREE.BoxGeometry(TILE_SIZE, TILE_HEIGHT, TILE_SIZE);
    const ballGeo = new THREE.SphereGeometry(BALL_RADIUS, 32, 32);

    const tileMat  = new THREE.MeshStandardMaterial({ color: 0x444444 });
    const startMat = new THREE.MeshStandardMaterial({ color: 0x2255ff });
    const goalMat  = new THREE.MeshStandardMaterial({ color: 0x22ff55 });
    const liftMat  = new THREE.MeshStandardMaterial({ color: 0xffff00 });
    const ballMat  = new THREE.MeshStandardMaterial({ color: 0xff2222 });

    let tiles = [];
    let lifts = [];
    let startTile, goalTile;
    let START_POS, GOAL_POS;

    const ball = new THREE.Mesh(ballGeo, ballMat);
    scene.add(ball);

    class Lift {
      constructor(x1,y1,z1,x2,y2,z2) {
        this.start = new THREE.Vector3(x1,y1,z1);
        this.end   = new THREE.Vector3(x2,y2,z2);
        this.progress = 0;
        this.forward = true;
        this.waitUntil = 0;
        this.distance = this.start.distanceTo(this.end);
        this.travelTime = Math.max(0.0001, this.distance / LIFT_SPEED);
        this.mesh = new THREE.Mesh(tileGeo, liftMat);
        scene.add(this.mesh);
        this.mesh.position.copy(this.start);
      }
      update(dtMs) {
        if (Date.now() < this.waitUntil) return;
        const delta = dtMs / (this.travelTime * 1000);
        this.progress += this.forward ? delta : -delta;
        if (this.progress >= 1) { this.progress = 1; this.forward = false; this.waitUntil = Date.now() + LIFT_PAUSE_MS; }
        if (this.progress <= 0) { this.progress = 0; this.forward = true;  this.waitUntil = Date.now() + LIFT_PAUSE_MS; }
        this.mesh.position.lerpVectors(this.start, this.end, this.progress);
      }
      reset() { this.progress = 0; this.forward = true; this.waitUntil = 0; this.mesh.position.copy(this.start); }
      dispose() { scene.remove(this.mesh); }
    }

    function loadLevel(index) {
      tiles.forEach(t => scene.remove(t));
      lifts.forEach(l => l.dispose && l.dispose());
      if (startTile) scene.remove(startTile);
      if (goalTile)  scene.remove(goalTile);
      tiles = []; lifts = []; startTile = goalTile = undefined;
      START_POS = GOAL_POS = undefined;

      const def = levels[index].level;
      def.forEach(obj => {
        if (obj.type === "floor") {
          if (obj.from) {
            for (let x = obj.from.x; x <= obj.to.x; x++) {
              for (let z = obj.from.z; z <= obj.to.z; z++) {
                const t = new THREE.Mesh(tileGeo, tileMat);
                t.position.set(x, -TILE_HEIGHT/2, z);
                scene.add(t); tiles.push(t);
              }
            }
          } else {
            const t = new THREE.Mesh(tileGeo, tileMat);
            t.position.set(obj.position.x, -TILE_HEIGHT/2, obj.position.z);
            scene.add(t); tiles.push(t);
          }
        }
        if (obj.type === "start") {
          startTile = new THREE.Mesh(tileGeo, startMat);
          startTile.position.set(obj.position.x, -TILE_HEIGHT/2, obj.position.z);
          scene.add(startTile); tiles.push(startTile);
          START_POS = new THREE.Vector3(obj.position.x, BALL_Y, obj.position.z);
        }
        if (obj.type === "goal") {
          goalTile = new THREE.Mesh(tileGeo, goalMat);
          goalTile.position.set(obj.position.x, -TILE_HEIGHT/2, obj.position.z);
          scene.add(goalTile); tiles.push(goalTile);
          GOAL_POS = new THREE.Vector3(obj.position.x, BALL_Y, obj.position.z);
        }
        if (obj.type === "lift") {
          const l = new Lift(obj.from.x, obj.from.y, obj.from.z, obj.to.x, obj.to.y, obj.to.z);
          lifts.push(l);
        }
      });

      resetGame();
    }

    const hud  = document.getElementById('hud');
    const menu = document.getElementById('menu');

    let ballPos = new THREE.Vector3();
    let moves = 0, startTime = 0, timerId;
    let bestMoves = null, bestTime = null;

    let velocityY = 0, falling = false, isMoving = false;
    let moveFrom = new THREE.Vector3(), moveTo = new THREE.Vector3();
    let moveStartTime = 0, moveDuration = 0.5 / MOVE_SPEED;
    let ridingLift = null;

    let dropStartY = null, dropStartTime = null;
    let landStartY = null, landTargetY = null, landStartTime = null;

    let gameRunning = false;
    let currentLevel = 0;

    function updateHUD() {
      const t = Math.max(0, Math.floor((Date.now() - startTime) / 1000));
      hud.innerHTML = `Moves: ${moves} | Time: ${t}s<br>Best Moves: ${bestMoves ?? '-'} | Best Time: ${bestTime ?? '-'}`;
    }

    function resetGame() {
      ballPos.copy(START_POS);
      ball.position.copy(ballPos);
      ball.rotation.set(0,0,0);
      velocityY = 0; falling = false; isMoving = false; moves = 0;
      dropStartY = null; landStartY = null;
      lifts.forEach(l => l.reset());
      gameRunning = false;
      startTime = Date.now();
      updateHUD();
    }

    function loseGame() {
      clearInterval(timerId);
      isMoving = false;
      falling = false;
      menu.style.display = 'flex';
      menu.innerHTML = `<h1>You Fell!</h1><button data-action="restart">Restart Level</button>`;
    }

    function winGame() {
      clearInterval(timerId);
      const duration = Math.floor((Date.now() - startTime) / 1000);
      if (!bestTime || duration < bestTime) bestTime = duration;
      if (!bestMoves || moves < bestMoves) bestMoves = moves;
      localStorage.setItem('bestTime', bestTime);
      localStorage.setItem('bestMoves', bestMoves);
      currentLevel++;
      if (currentLevel < levels.length) {
        startLevel(currentLevel);
      } else {
        menu.style.display = 'flex';
        menu.innerHTML = `<h1>You Win All Levels!</h1><button data-action="restart">Restart Last Level</button>`;
        currentLevel = levels.length - 1;
      }
    }

    function startLevel(index) {
      loadLevel(index);
      clearInterval(timerId);
      timerId = setInterval(updateHUD, 1000);
      setTimeout(() => { gameRunning = true; }, 2000);
    }

    function restartLevel() { startLevel(currentLevel); }

    menu.addEventListener('click', (e) => {
      const btn = e.target.closest('button');
      if (!btn) return;
      const action = btn.getAttribute('data-action');
      if (action === 'start') {
        e.preventDefault();
        menu.style.display = 'none';
        currentLevel = 0;
        startLevel(currentLevel);
      } else if (action === 'restart') {
        e.preventDefault();
        menu.style.display = 'none';
        startLevel(currentLevel);
      }
    });

    let camYaw = DEFAULT_CAM.yaw;
    let camPitch = DEFAULT_CAM.pitch;
    let camYawTarget = camYaw;
    let camPitchTarget = camPitch;
    let camDist = DEFAULT_CAM.dist;
    let camDistTarget = camDist;

    window.addEventListener('keydown', (e) => {
      camYawTarget = DEFAULT_CAM.yaw;
      camPitchTarget = DEFAULT_CAM.pitch;
      camDistTarget = DEFAULT_CAM.dist;
      if (!['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)) return;
      e.preventDefault();
      if (isMoving || falling) return;
      ridingLift = null; dropStartY = null; landStartY = null;
      const dir = new THREE.Vector3();
      if (e.key === 'ArrowUp')    dir.set(1, 0, 0);
      if (e.key === 'ArrowDown')  dir.set(-1,0, 0);
      if (e.key === 'ArrowLeft')  dir.set(0, 0,-1);
      if (e.key === 'ArrowRight') dir.set(0, 0, 1);
      moveFrom.copy(ballPos);
      moveTo.copy(ballPos).add(dir);
      window.__moveAxis = new THREE.Vector3(dir.z, 0, -dir.x).normalize();
      moveStartTime = performance.now();
      isMoving = true;
      moves++;
    });

    let dragging = false, lastX = 0, lastY = 0;
    window.addEventListener('mousedown', e => { dragging = true; lastX = e.clientX; lastY = e.clientY; });
    window.addEventListener('mouseup',   () => { dragging = false; });
    window.addEventListener('mousemove', e => {
      if (!dragging) return;
      const dx = e.clientX - lastX, dy = e.clientY - lastY;
      lastX = e.clientX; lastY = e.clientY;
      camYawTarget   += dx * 0.003;
      camPitchTarget += dy * 0.003;
      camPitchTarget = Math.max(-0.9, Math.min(0.9, camPitchTarget));
    });
    window.addEventListener('wheel', e => {
      camDistTarget += (e.deltaY > 0 ? 1 : -1) * 0.6;
      camDistTarget = Math.max(3, Math.min(12, camDistTarget));
    }, { passive: true });

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    function isTileAt(x, y, z) {
      return tiles.some(t => Math.abs(t.position.x - x) < 0.1 && Math.abs(t.position.y - y) < 0.1 && Math.abs(t.position.z - z) < 0.1);
    }

    let lastTime = performance.now();
    function animate() {
      requestAnimationFrame(animate);
      const now = performance.now();
      const dt = now - lastTime;
      lastTime = now;

      if (gameRunning) { for (const l of lifts) l.update(dt); }

      if (isMoving && !falling) {
        const t = Math.min(1, (now - moveStartTime) / ( (0.5 / MOVE_SPEED) * 1000 ));
        ballPos.lerpVectors(moveFrom, moveTo, t);
        for (const lift of lifts) {
          if (Math.abs(lift.mesh.position.x - ballPos.x) < 0.1 &&
              Math.abs(lift.mesh.position.z - ballPos.z) < 0.1) {
            ballPos.set(lift.mesh.position.x, lift.mesh.position.y + BALL_RADIUS, lift.mesh.position.z);
            ridingLift = lift;
          }
        }
        const dist = TILE_SIZE * t;
        const angle = dist / BALL_RADIUS;
        ball.rotation.set(0,0,0);
        ball.rotateOnWorldAxis(window.__moveAxis || new THREE.Vector3(0,0,0), angle);
        if (t >= 1) {
          isMoving = false;
          ballPos.copy(moveTo);
          ridingLift = null;
          for (const lift of lifts) {
            if (Math.abs(lift.mesh.position.x - ballPos.x) < 0.1 &&
                Math.abs(lift.mesh.position.z - ballPos.z) < 0.1) {
              ridingLift = lift;
              dropStartY = null;
              landStartY = ballPos.y;
              landTargetY = lift.mesh.position.y + BALL_RADIUS;
              landStartTime = performance.now();
              break;
            }
          }
          if (!ridingLift) {
            if (isTileAt(Math.round(ballPos.x), Math.round(ballPos.y), Math.round(ballPos.z))) {
              ballPos.x = Math.round(ballPos.x);
              ballPos.z = Math.round(ballPos.z);
            } else {
              falling = true; velocityY = 0;
            }
          }
          if (ballPos.x === GOAL_POS.x && ballPos.z === GOAL_POS.z) { winGame(); }
        }
      }

      if (falling) {
        velocityY -= 0.015;
        ballPos.y += velocityY;
        if (ballPos.y < -5) loseGame();
      } else if (!isMoving) {
        if (ridingLift) {
          if (landStartY !== null) {
            const elapsed = performance.now() - landStartTime;
            const t = Math.min(1, elapsed / LAND_DURATION);
            ballPos.y = landStartY + (landTargetY - landStartY) * t;
            ballPos.x = ridingLift.mesh.position.x;
            ballPos.z = ridingLift.mesh.position.z;
            if (t >= 1) landStartY = null;
          } else {
            ballPos.set(ridingLift.mesh.position.x,
                        ridingLift.mesh.position.y + BALL_RADIUS,
                        ridingLift.mesh.position.z);
          }
          dropStartY = null;
        } else {
          if (dropStartY === null) { dropStartY = ballPos.y; dropStartTime = performance.now(); }
          const elapsed = performance.now() - dropStartTime;
          const t = Math.min(1, elapsed / DROP_DURATION);
          ballPos.y = dropStartY + (BALL_Y - dropStartY) * t;
          ballPos.x = Math.round(ballPos.x);
          ballPos.z = Math.round(ballPos.z);
        }
      }

      ball.position.copy(ballPos);
      camYaw += (camYawTarget - camYaw) * CAM_SMOOTH;
      camPitch += (camPitchTarget - camPitch) * CAM_SMOOTH;
      camDist += (camDistTarget - camDist) * CAM_SMOOTH;
      const cx = ballPos.x + Math.cos(camYaw) * Math.cos(camPitch) * camDist;
      const cy = ballPos.y + Math.sin(camPitch) * camDist + 1;
      const cz = ballPos.z + Math.sin(camYaw) * Math.cos(camPitch) * camDist;
      camera.position.set(cx, cy, cz);
      camera.lookAt(ballPos.x, ballPos.y, ballPos.z);

      renderer.render(scene, camera);
    }
    animate();

  })();
  </script>
</body>
</html>
