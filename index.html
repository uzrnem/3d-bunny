<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Ball Rolling Game</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; }
    canvas { display: block; }
    #hud {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      background: rgba(0,0,0,0.5);
      padding: 8px 10px;
      border-radius: 8px;
      user-select:none;
      line-height: 1.3;
    }
    #control {
      position: absolute;
      top: 70px;
      left: 10px;
      color: white;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      background: rgba(0,0,0,0.5);
      padding: 8px 10px;
      border-radius: 8px;
      user-select:none;
      line-height: 1.3;
    }
    #menu {
      position: absolute;
      inset: 0;
      display: flex; align-items: center; justify-content: center; flex-direction: column;
      background: rgba(0,0,0,0.8);
      color: white; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      z-index: 10;
    }
    button { margin-top: 12px; padding: 10px 20px; font-size: 16px; border-radius: 6px; border: none; cursor: pointer; }
  </style>
</head>
<body>
  <div id="hud">Moves: 0 | Time: 0s<br>Best Moves: - | Best Time: -</div>
  <div id="control"></div>
  <div id="menu"><h1>Ball Rolling Game</h1><button data-action="start">Start Game</button></div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/examples/js/loaders/GLTFLoader.js"></script>

  <script>
  (() => {
    const TILE_SIZE = 1;
    const TILE_HEIGHT = 0.1;
    const BALL_RADIUS = 0.4;
    const DIVIDE_HEIGHT_BY = 3; // tiles are placed at y/3 in 3D space

    const MOVE_SPEED = 3; // Ball speed in tiles per second
    const CAM_SMOOTH = 0.12;
    const LIFT_SPEED = 2.0;
    const LIFT_PAUSE_MS = 2000;
    const DROP_DURATION = 200;
    const LAND_DURATION = 200;
    var OK_FALL_Y = -5; // if ball falls below this y → lose

    const DEFAULT_CAM = {
      yaw: Math.PI, // * 0.75, // + , // - Math.PI/4, // - Math.PI/4,
      pitch: 0.35,
      dist: 6
    };

    // ------------ Levels ------------
    const levels = [
      {
        "elements": [
          {"type":"floor","from":{"x":0,"y":0,"z":0},"to":{"x":15,"y":0,"z":15}},
          { "type": "custom", "position": { "x": 5, "y": 0, "z": 3 } },
          {"type":"hero","position":{"x":-1,"y":0,"z":0}},
          {"type":"floor","position":{"x":-1,"y":0,"z":15}},
          {"type":"floor","position":{"x":0,"y":0,"z":-1}},
          {"type":"floor","position":{"x":15,"y":0,"z":-1}},
          {"type":"goal","position":{"x":15,"y":0,"z":15}},
          {"type":"lift","from":{"x":-1,"y":0,"z":1},"to":{"x":-1,"y":0,"z":14}},
          {"type":"lift","from":{"x":1,"y":0,"z":-1},"to":{"x":14,"y":0,"z":-1}},
          {"type":"lift","from":{"x":-1,"y":0,"z":-1},"to":{"x":15,"y":15,"z":15}},
          {"type":"lift","from":{"x":16,"y":0,"z":-1},"to":{"x":16,"y":0,"z":15}},
          {"type":"lift","from":{"x":-2,"y":0,"z":0},"to":{"x":-2,"y":-15,"z":0}},
          {"type":"teleporter","entry1":{"x":2,"y":0,"z":2},"entry2":{"x":13,"y":0,"z":13}},
          {"type":"stair","position":{"x":16,"y":1,"z":1},"direction":"right","count":"6"},
          {"type":"floor","position":{"x":0,"y":0,"z":-2}},
          {"type":"stair","position":{"x":1,"y":0,"z":-2},"direction":"right","count":"6"},
          {"type":"bonuscrystall","position":{"x":8,"y":0,"z":9}},
          {"type":"bonuscrystall","position":{"x":8,"y":0,"z":7}},
          { "type": "ghost", "position": { "x": 7, "y": 0, "z": 3 } },
          {"type":"falsefloor","position":{"x":1,"y":0,"z":-3}},
          {"type":"falsefloor","position":{"x":0,"y":0,"z":-3}},
          {"type":"falsefloor","position":{"x":-1,"y":0,"z":-3}},
          {"type":"falsefloor","position":{"x":2,"y":0,"z":-3}},
          {"type":"falsefloor","position":{"x":3,"y":0,"z":-3}},
          {"type":"falsefloor","position":{"x":4,"y":0,"z":-3}},
          {"type":"falsefloor","position":{"x":5,"y":0,"z":-3}},
        ]
      }
    ];
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const loader = new THREE.CubeTextureLoader();
    const gltfLoader = new THREE.GLTFLoader();

    function loadGLBModel(path, onLoad) {
      gltfLoader.load(path, (gltf) => {
        const model = gltf.scene;
        model.traverse((child) => {
          if (child.isMesh) {
            child.castShadow = true;
            child.receiveShadow = true;
          }
        });
        onLoad(model);
      });
    }
    const skybox = loader.load([
      './bg/bg_front.bmp',
      './bg/bg_back.bmp',
      './bg/bg_top.bmp',
      './bg/bg_bottom.bmp',
      './bg/bg_right.bmp',
      './bg/bg_left.bmp'
    ]);
    scene.background = skybox;

    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(5, 10, 5);
    scene.add(dirLight);

    // --- Sound Setup ---
    const listener = new THREE.AudioListener();
    camera.add(listener);

    const audioLoader = new THREE.AudioLoader();
    const sounds = {};

    function loadSound(name, file, loop=false, volume=0.5) {
      const sound = new THREE.Audio(listener);
      audioLoader.load(`./sounds/${file}`, buffer => {
        sound.setBuffer(buffer);
        sound.setLoop(loop);
        sound.setVolume(volume);
      });
      sounds[name] = sound;
    }

    // Load Texture
    const tilesTextureLoader = new THREE.TextureLoader();
    const tileTexture = tilesTextureLoader.load("./bg/tiles.png"); // <-- replace with your file path
    const falseFloorTexture = tilesTextureLoader.load("./bg/falsefloor.png"); // <-- replace with your file path
    const goalTexture = tilesTextureLoader.load("./bg/goal.png"); // <-- replace with your file path
    const destinationTexture = tilesTextureLoader.load("./bg/destination.png"); // <-- replace with your file path
    const diamondTexture = tilesTextureLoader.load("./bg/diamond.png"); // <-- replace with your file path
    const liftTexture = tilesTextureLoader.load("./bg/lift.png"); // <-- replace with your file path
    const teleportTexture = tilesTextureLoader.load("./bg/teleport.png"); // <-- replace with your file path
    const ballTexture = tilesTextureLoader.load("./bg/ball.png"); // <-- replace with your file path

    const tileGeo = new THREE.BoxGeometry(TILE_SIZE, TILE_HEIGHT, TILE_SIZE);
    const ballGeo = new THREE.SphereGeometry(BALL_RADIUS, 32, 32);

    const tileMat  = new THREE.MeshBasicMaterial({ map: tileTexture });
    const falseMat  = new THREE.MeshBasicMaterial({ map: falseFloorTexture });
    const goalMat  = new THREE.MeshStandardMaterial({ map: goalTexture });
    const destinationMat  = new THREE.MeshStandardMaterial({ map: destinationTexture });
    const liftMat  = new THREE.MeshBasicMaterial({ map: liftTexture });
    const teleportMat  = new THREE.MeshBasicMaterial({ map: teleportTexture });
    const crystallMat  = new THREE.MeshBasicMaterial({ map: diamondTexture });
    const ballMat  = new THREE.MeshBasicMaterial({ map: ballTexture });

    let tiles = [];
    let lifts = [];
    let falseFloors = [];
    let teleporters = [];
    let crystals = [];
    let ghosts = [];
    let customs = [];
    let crystalsRemaining = 0;
    let goalActive = false;
    let startTile, goalTile;
    let goalLight = null;
    let START_POS, GOAL_POS;

    const ball = new THREE.Mesh(ballGeo, ballMat);
    scene.add(ball);

    // ------------ Moving platforms, teleporter, crystals ------------
    class Custom {
      constructor(pos) {
        this.pos = new THREE.Vector3(pos.x, pos.y / DIVIDE_HEIGHT_BY, pos.z);

        const geo = new THREE.BoxGeometry(1, 1, 1);
        const texture = new THREE.TextureLoader().load("./bg/crate.gif");
        const mat = new THREE.MeshBasicMaterial({ map: texture });

        this.mesh = new THREE.Mesh(geo, mat);
        this.mesh.position.set(this.pos.x, this.pos.y + 0.5, this.pos.z);
        scene.add(this.mesh);
      }

      isBlocking(x, y, z) {
        return Math.abs(x - this.pos.x) < 0.1 && Math.abs(y-this.pos.y) < 0.5 && Math.abs(z - this.pos.z) < 0.1;
      }

      dispose() {
        scene.remove(this.mesh);
        this.mesh.geometry.dispose();
        this.mesh.material.dispose();
      }
    }

    class Lift {
      constructor(x1,y1,z1,x2,y2,z2) {
        this.start = new THREE.Vector3(x1,y1/DIVIDE_HEIGHT_BY,z1);
        this.end   = new THREE.Vector3(x2,y2/DIVIDE_HEIGHT_BY,z2);
        this.progress = 0;
        this.forward = true;
        this.waitUntil = 0;
        this.distance = this.start.distanceTo(this.end);
        this.travelTime = Math.max(0.0001, this.distance / LIFT_SPEED);
        this.mesh = new THREE.Mesh(tileGeo, liftMat);
        loadGLBModel("./glb/lift.glb", (model) => {
          this.mesh = model;
          this.mesh.scale.set(0.2, 0.2, 0.2);   // adjust scale
          this.mesh.position.copy(this.start);
          scene.add(this.mesh);
        });
        //this.mesh = new THREE.Mesh(tileGeo, liftMat);
        //scene.add(this.mesh);
        //this.mesh.position.copy(this.start);
      }
      update(dtMs) {
        if (Date.now() < this.waitUntil) return;
        const delta = dtMs / (this.travelTime * 1000);
        this.progress += this.forward ? delta : -delta;
        if (this.progress >= 1) { this.progress = 1; this.forward = false; this.waitUntil = Date.now() + LIFT_PAUSE_MS; }
        if (this.progress <= 0) { this.progress = 0; this.forward = true;  this.waitUntil = Date.now() + LIFT_PAUSE_MS; }
        this.mesh.position.lerpVectors(this.start, this.end, this.progress);
      }
      reset() { this.progress = 0; this.forward = true; this.waitUntil = 0; this.mesh.position.copy(this.start); }
      dispose() { scene.remove(this.mesh); }
    }

    class Teleporter {
      constructor(e1, e2) {
        this.entry1 = new THREE.Vector3(e1.x, e1.y/DIVIDE_HEIGHT_BY, e1.z);
        this.entry2 = new THREE.Vector3(e2.x, e2.y/DIVIDE_HEIGHT_BY, e2.z);
        this.mesh1 = new THREE.Mesh(tileGeo, teleportMat);
        this.mesh2 = new THREE.Mesh(tileGeo, teleportMat);
        this.mesh1.position.set(e1.x, e1.y/DIVIDE_HEIGHT_BY, e1.z);
        this.mesh2.position.set(e2.x, e2.y/DIVIDE_HEIGHT_BY, e2.z);
        scene.add(this.mesh1);
        scene.add(this.mesh2);
      }
      checkTeleport(pos) {
        if (Math.abs(pos.x - this.entry1.x) < 0.1 && this.entry1.distanceTo(pos) < 0.5 && Math.abs(pos.z - this.entry1.z) < 0.1) {
          pos.copy(this.entry2);
        } else if (Math.abs(pos.x - this.entry2.x) < 0.1 && this.entry2.distanceTo(pos) < 0.5 && Math.abs(pos.z - this.entry2.z) < 0.1) {
          pos.copy(this.entry1);
        }
      }
      checkIfExactlyOnEntry1(pos) {
        if (Math.abs(pos.x - this.entry1.x) < 0.1 && Math.abs(this.entry1.y + BALL_RADIUS - pos.y) && Math.abs(pos.z - this.entry1.z) < 0.1) {
          return true;
        }
        return false
      }
      checkIfExactlyOnEntry2(pos) {
        if (Math.abs(pos.x - this.entry2.x) < 0.1 && Math.abs(this.entry2.y + BALL_RADIUS - pos.y) && Math.abs(pos.z - this.entry2.z) < 0.1) {
          return true;
        }
        return false
      }

      dispose() {
        scene.remove(this.mesh1);
        scene.remove(this.mesh2);
      }
    }

    class BonusCrystall {
      constructor(pos) {
        // place crystal just above floor (y/3 for tiles) plus some lift for visibility
        const y = pos.y / 3 + .5;
        this.pos = new THREE.Vector3(pos.x, y, pos.z);

        const geo = new THREE.OctahedronGeometry(0.3);
        this.mesh = new THREE.Mesh(geo, crystallMat);
        this.mesh.position.copy(this.pos);
        scene.add(this.mesh);

        this.collected = false;
      }
      checkCollect(ballPos) {
        if (this.collected) return false;

        // Check same tile (x and z match exactly)
        if (Math.abs(ballPos.x - this.pos.x) < 0.1 && Math.abs(ballPos.z - this.pos.z) < 0.1) {
          // Check vertical closeness
          if (Math.abs(ballPos.y - this.pos.y) < 2) {
            this.collected = true;
            scene.remove(this.mesh);
            crystalsRemaining--;
            if (sounds.crystall) {
              sounds.crystall.play();
            }

            if (crystalsRemaining <= 0) {
              if (sounds.score) {
                sounds.score.play();
              }
              goalTile.material = destinationMat;
              goalActive = true;

              // 🔥 Torch-like green light
              if (goalLight) {
                scene.remove(goalLight);
                goalLight = null;
              }

              goalLight = new THREE.PointLight(0x00ff00, 5, 12); // (color, intensity, distance)
              goalLight.position.set(goalTile.position.x, goalTile.position.y + 2, goalTile.position.z);

              // Optional glowing sphere to show the light source
              const glowGeo = new THREE.SphereGeometry(0.3, 16, 16);
              const glowMat = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.6 });
              const glowMesh = new THREE.Mesh(glowGeo, glowMat);
              glowMesh.name = "goalGlowMesh";
              goalLight.add(glowMesh);

              scene.add(goalLight);
            }
            return true;
          }
        }
        return false;
      }
      dispose() { scene.remove(this.mesh); }
    }

    class FalseFloor {
      constructor(pos) {
        this.pos = new THREE.Vector3(pos.x, pos.y/DIVIDE_HEIGHT_BY, pos.z);
        this.mesh = new THREE.Mesh(tileGeo, falseMat);
        this.mesh.position.set(this.pos.x, this.pos.y, this.pos.z);
        scene.add(this.mesh);

        this.triggered = false;   // countdown started?
        this.fallAt = null;       // timestamp when fall starts
        this.falling = false;     // is falling now
        this.fallSpeed = 0;       // vertical speed
      }

      update(ballPos) {
        // 1) Start countdown when ball steps on tile
        if (!this.triggered &&
            Math.abs(ballPos.x - this.pos.x) < 0.2 &&
            Math.abs(ballPos.z - this.pos.z) < 0.2 &&
            Math.abs(ballPos.y - (this.pos.y + BALL_RADIUS)) < 0.4) {
          this.triggered = true;
          this.fallAt = Date.now() + 3000; // 3s wait
        }

        // 2) Begin falling after countdown
        if (this.triggered && !this.falling && Date.now() >= this.fallAt) {
          this.falling = true;
          if (sounds.falsefloor) {
            sounds.falsefloor.play();
          }
          this.fallSpeed = -LIFT_SPEED / 8; // start faster than lifts

          // Remove from safe ground list
          const idx = tiles.indexOf(this.mesh);
          if (idx !== -1) tiles.splice(idx, 1);

          // If player is on it → make player fall too
          if (Math.abs(ballPos.x - this.pos.x) < 0.2 &&
              Math.abs(ballPos.z - this.pos.z) < 0.2) {
            falling = true;
            velocityY = this.fallSpeed;
          }
        }

        // 3) Animate falling
        if (this.falling) {
          this.fallSpeed -= 0.02;               // gravity
          this.mesh.position.y += this.fallSpeed;

          // Remove from scene when out of view
          if (this.mesh.position.y < -5) {
            scene.remove(this.mesh);
            this.mesh.geometry.dispose();
            this.mesh.material.dispose();
            return true; // signal to delete from array
          }
        }
        return false;
      }

      dispose() { scene.remove(this.mesh); }
    }

    class Tornado {
      constructor(pos, dir) {
        this.pos = pos.clone();
        this.dir = dir.clone().normalize();
        this.startTime = Date.now();
        this.lifetime = 20; // seconds

        this.mesh = new THREE.Mesh(
          new THREE.ConeGeometry(0.3, 0.6, 12, 1, true),
          new THREE.MeshBasicMaterial({ color: 0x88ccff, wireframe: true, transparent: true })
        );
        this.mesh.position.copy(this.pos);
        scene.add(this.mesh);
      }

      update(dt) {
        const elapsed = (Date.now() - this.startTime) / 1000;

        // 🎯 Move forward
        this.pos.addScaledVector(this.dir, LIFT_SPEED * dt/1000);

        // 🌪️ Spin
        this.mesh.rotation.y += 0.2;

        // 🌪️ Wobble
        const wobbleMag = 0.2;
        const wobbleDir = new THREE.Vector3(-this.dir.z, 0, this.dir.x);
        const wobbleOffset = wobbleDir.multiplyScalar(Math.sin(elapsed * 10) * wobbleMag);

        this.mesh.position.copy(this.pos.clone().add(wobbleOffset));

        // 💥 Collision with ball
        if (this.pos.distanceTo(ballPos) < 0.5) {
          if (sounds.gameover) {
            sounds.gameover.play();
          }
          loseGame("Hit by Tornado");
        }

        // ❌ Fade out in last 2s
        const timeLeft = this.lifetime - elapsed;
        if (timeLeft <= 2) {
          const fade = Math.max(0, timeLeft / 2); // 1 → 0
          this.mesh.scale.set(fade, fade, fade);
          this.mesh.material.opacity = fade;
        }

        // ❌ Remove after lifetime
        if (elapsed > this.lifetime) {
          scene.remove(this.mesh);
          this.mesh.geometry.dispose();
          this.mesh.material.dispose();
          return false;
        }

        return true;
      }
    }

    class Ghost {
      constructor(pos) {
        this.start = new THREE.Vector3(pos.x, pos.y / DIVIDE_HEIGHT_BY + 0.5, pos.z);
        this.pos = this.start.clone();

        loadGLBModel("./glb/ghost.glb", (model) => {
          this.mesh = model;
          this.mesh.scale.set(0.2, 0.2, 0.2);
          this.mesh.position.copy(this.start);
          this.mesh.rotation.x = -Math.PI / 2;
          scene.add(this.mesh);
        });

        this.speed = LIFT_SPEED; // roam speed
        this.target = null; // next target position
        this.range = 2; // 4x4 grid means ±2 from start
        this.tornados = [];
        this.cooldown = 0;
      }

      pickNextTarget() {
        // Pick a random adjacent tile within 4x4 range
        const dirs = [
          new THREE.Vector3(1, 0, 0),
          new THREE.Vector3(-1, 0, 0),
          new THREE.Vector3(0, 0, 1),
          new THREE.Vector3(0, 0, -1)
        ];
        const shuffled = dirs.sort(() => Math.random() - 0.5);
        for (const d of shuffled) {
          const next = this.pos.clone().add(d);
          if (Math.abs(next.x - this.start.x) <= this.range &&
              Math.abs(next.z - this.start.z) <= this.range &&
              hasFloorBelow(next.x, next.y, next.z)) {
            this.target = next;
            return;
          }
        }
        this.target = null;
      }

      update(dt) {
        // If no target → pick one
        if (!this.target) {
          this.pickNextTarget();
          return;
        }

        // Move towards target
        const dir = this.target.clone().sub(this.pos).setY(0);
        const dist = dir.length();
        if (dist < 0.05) {
          this.pos.copy(this.target);
          this.pickNextTarget();
        } else {
          dir.normalize();
          this.pos.addScaledVector(dir, this.speed * dt / 1000);
        }

        // Apply bobbing
        this.mesh.position.set(this.pos.x, this.pos.y, this.pos.z);

        // Collision with player
        if (this.pos.distanceTo(ballPos) < 0.6) {
          if (sounds.gameover) {
            sounds.gameover.play();
          }
          loseGame("Caught by Ghost");
        }

        // Tornado attack
        if (this.pos.distanceTo(ballPos) < 6 && Date.now() > this.cooldown) {
          const dirToPlayer = ballPos.clone().sub(this.pos).setY(0).normalize();
          this.tornados.push(new Tornado(this.pos, dirToPlayer));
          this.cooldown = Date.now() + 2000;
        }

        // Update tornados
        for (let i = this.tornados.length - 1; i >= 0; i--) {
          if (!this.tornados[i].update(dt)) this.tornados.splice(i, 1);
        }
      }

      dispose() {
        scene.remove(this.mesh);
        this.tornados.forEach(t => scene.remove(t.mesh));
      }
    }

    // ------------ Level loading ------------
    function loadLevel(index) {
      tiles.forEach(t => scene.remove(t));
      tiles = [];
      lifts.forEach(l => l.dispose && l.dispose());
      lifts = [];
      falseFloors.forEach(f => f.dispose());
      falseFloors = [];
      teleporters.forEach(t => t.dispose());
      teleporters = [];
      crystals.forEach(c => c.dispose());
      crystals = [];
      ghosts.forEach(g => g.dispose());
      ghosts = [];
      customs.forEach(c => c.dispose());
      customs = [];
      if (startTile) scene.remove(startTile);
      if (goalTile)  scene.remove(goalTile);
      crystalsRemaining = 0;
      goalActive = false;
      startTile = goalTile = undefined;
      START_POS = GOAL_POS = undefined;
      if (goalLight) {
        scene.remove(goalLight);
        goalLight = null;
      }

      const def = levels[index].elements;
      def.forEach(obj => {
        if (obj.type === "floor") {
          if (obj.from && obj.to) {
            const minX = Math.min(obj.from.x, obj.to.x);
            const maxX = Math.max(obj.from.x, obj.to.x);
            const minY = Math.min(obj.from.y, obj.to.y);
            const minZ = Math.min(obj.from.z, obj.to.z);
            const maxZ = Math.max(obj.from.z, obj.to.z);

            for (let x = minX; x <= maxX; x++) {
              for (let z = minZ; z <= maxZ; z++) {
                const t = new THREE.Mesh(tileGeo, tileMat);
                t.position.set(x, minY/DIVIDE_HEIGHT_BY, z);
                scene.add(t); tiles.push(t);
              }
            }
          } else {
            const t = new THREE.Mesh(tileGeo, tileMat);
            t.position.set(obj.position.x, obj.position.y/DIVIDE_HEIGHT_BY, obj.position.z);
            scene.add(t); tiles.push(t);
          }
        } else if (obj.type === "hero") {
          startTile = new THREE.Mesh(tileGeo, tileMat);
          startTile.position.set(obj.position.x, obj.position.y/DIVIDE_HEIGHT_BY, obj.position.z);
          scene.add(startTile); tiles.push(startTile);
          START_POS = new THREE.Vector3(obj.position.x, obj.position.y/DIVIDE_HEIGHT_BY, obj.position.z);
        } else if (obj.type === "goal") {
          goalTile = new THREE.Mesh(tileGeo, goalMat); // dark until activated
          goalTile.position.set(obj.position.x, obj.position.y/DIVIDE_HEIGHT_BY, obj.position.z);
          scene.add(goalTile); tiles.push(goalTile);
          GOAL_POS = new THREE.Vector3(obj.position.x, obj.position.y/DIVIDE_HEIGHT_BY, obj.position.z);
          goalActive = false;
        } else if (obj.type === "lift") {
          const l = new Lift(obj.from.x, obj.from.y, obj.from.z, obj.to.x, obj.to.y, obj.to.z);
          lifts.push(l);
        } else if (obj.type === "teleporter") {
          const t = new Teleporter(obj.entry1, obj.entry2);
          teleporters.push(t);
        } else if (obj.type === "bonuscrystall") {
          obj.position = obj.position || { x: 0, y: 0, z: 0 };
          const c = new BonusCrystall(obj.position);
          crystals.push(c);
          crystalsRemaining++;
        } else if (obj.type === "stair") {
          const dirMap = {
            "right": new THREE.Vector3(1, 0, 0),
            "left":  new THREE.Vector3(-1, 0, 0),
            "front": new THREE.Vector3(0, 0, 1),
            "back": new THREE.Vector3(0, 0, -1)
          };
          const dir = dirMap[obj.direction] || new THREE.Vector3(1,0,0);
          const steps = parseInt(obj.count) || 1;
/*
          var start = obj.position.y - 1;
          var end = start + steps;
          var yCords = [];
          for (var i = start + 1; i <= end - 1; i++) {
            //  start + (n * (end - start)) / (count - 1)
            console.log(` >  yCord: ${start + (i * (end - start)) / (steps - 1)}`);
          }
          console.log(` >  obj.position.y: ${obj.position.y}, steps: ${steps}`); */


          for (let i = 0; i < steps; i++) {
            const t = new THREE.Mesh(tileGeo, tileMat);
            const pos = new THREE.Vector3(
              obj.position.x + dir.x * i,
              obj.position.y + i*1.5,
              obj.position.z + dir.z * i
            );
            t.position.set(pos.x, pos.y / DIVIDE_HEIGHT_BY, pos.z);
            //console.log(`Stair step at ${pos.x}, ${pos.y}, ${pos.z}`);
            scene.add(t);
            tiles.push(t);
          }
        } else if (obj.type === "falsefloor") {
          const f = new FalseFloor(obj.position);
          falseFloors.push(f);
          tiles.push(f.mesh); // still counts as a tile initially
        } else if (obj.type === "ghost" || obj.type === "monkey" || obj.type === "mummy" || obj.type === "mage") {
          const g = new Ghost(obj.position || obj.from);
          ghosts.push(g);
        } else {
          if (obj.position) {
            if (obj.type === "custom") {
              const c = new Custom(obj.position);
              customs.push(c);
            }
            const t = new THREE.Mesh(tileGeo, tileMat);
            t.position.set(obj.position.x, obj.position.y/DIVIDE_HEIGHT_BY, obj.position.z);
            scene.add(t); tiles.push(t);
          }
        }
      });

      resetGame();
    }

    // ------------ HUD & game state ------------
    const hud  = document.getElementById('hud');
    const menu = document.getElementById('menu');

    let ballPos = new THREE.Vector3();
    let moves = 0, startTime = 0, timerId;
    let bestMoves = null, bestTime = null;

    let velocityY = 0, falling = false, isMoving = false;
    let moveFrom = new THREE.Vector3(), moveTo = new THREE.Vector3();
    let moveStartTime = 0;
    let ridingLift = null;

    let dropStartY = null, dropStartTime = null;
    let landStartY = null, landTargetY = null, landStartTime = null;

    let gameRunning = false;
    let currentLevel = 0;

    function updateHUD() {
      const t = Math.max(0, Math.floor((Date.now() - startTime) / 1000));
      hud.innerHTML = `Moves: ${moves} | Time: ${t}s<br>Best Moves: ${bestMoves ?? '-'} | Best Time: ${bestTime ?? '-'}`;
    }

    // ------------ Direction memory (tank-style) ------------
    // Order: 0:+X (east), 1:+Z (south), 2:-X (west), 3:-Z (north)
    const DIRS = [
      new THREE.Vector3(1,0,0),
      new THREE.Vector3(0,0,1),
      new THREE.Vector3(-1,0,0),
      new THREE.Vector3(0,0,-1)
    ];
    const YAW_FROM_INDEX = [0, Math.PI/2, Math.PI, -Math.PI/2];
    let dirIndex = 0; // start facing +X

    function updateCameraBehind() {
      // Camera yaw should be opposite to the facing direction, so it looks at the ball from behind.
      //camYawTarget = YAW_FROM_INDEX[dirIndex] + Math.PI;
      // Keep pitch and distance as-is (or you can uncomment below to keep them steady)
      // camPitchTarget = DEFAULT_CAM.pitch;
      // camDistTarget = DEFAULT_CAM.dist;
      let desiredYaw = YAW_FROM_INDEX[dirIndex] + Math.PI;

      // Normalize to [-PI, PI]
      desiredYaw = Math.atan2(Math.sin(desiredYaw), Math.cos(desiredYaw));

      // Adjust target so the rotation is always the shortest way
      let delta = desiredYaw - camYaw;
      delta = Math.atan2(Math.sin(delta), Math.cos(delta)); // wrap to [-PI, PI]

      camYawTarget = camYaw + delta;
      camPitchTarget = DEFAULT_CAM.pitch;
      camDistTarget = DEFAULT_CAM.dist;
    }

    function resetGame() {
      ballPos.copy(START_POS);
      ball.position.copy(ballPos);
      ball.rotation.set(0,0,0);
      velocityY = 0; falling = false; isMoving = false; moves = 0;
      dropStartY = null; landStartY = null;
      lifts.forEach(l => l.reset());
      gameRunning = false;
      startTime = Date.now();
      // Reset facing and camera
      dirIndex = 0;
      updateCameraBehind();
      camYaw = camYawTarget; // snap at reset
      camPitch = DEFAULT_CAM.pitch;
      camDist = DEFAULT_CAM.dist;
      updateHUD();
    }

    function loseGame(reason) {
      clearInterval(timerId);
      isMoving = false;
      falling = false;
      menu.style.display = 'flex';
      menu.innerHTML = `<h1>${reason}!</h1><button data-action="restart">Restart Level</button>`;
    }

    function winGame() {
      if (sounds.exit) {
        sounds.exit.play();
      }
      clearInterval(timerId);
      const duration = Math.floor((Date.now() - startTime) / 1000);
      if (!bestTime || duration < bestTime) bestTime = duration;
      if (!bestMoves || moves < bestMoves) bestMoves = moves;
      localStorage.setItem('bestTime', bestTime);
      localStorage.setItem('bestMoves', bestMoves);
      currentLevel++;
      if (currentLevel < levels.length) {
        startLevel(currentLevel);
      } else {
        menu.style.display = 'flex';
        menu.innerHTML = `<h1>You Win All Levels!</h1><button data-action="restart">Restart Last Level</button>`;
        currentLevel = levels.length - 1;
      }
    }

    function startLevel(index) {
      loadLevel(index);
      clearInterval(timerId);
      timerId = setInterval(updateHUD, 1000);
      setTimeout(() => { gameRunning = true; }, 2000);
      playRandomBG();
    }

    function playRandomBG() {
      const bgTracks = ["bg_forest_1", "bg_forest_2", "bg_forest_3"];
      const pick = bgTracks[Math.floor(Math.random() * bgTracks.length)];

      // Stop any currently playing bg track
      Object.keys(sounds).forEach(k => {
        if (k.startsWith("bg_") && sounds[k].isPlaying) sounds[k].stop();
      });

      const sound = sounds[pick];
      if (sound) {
        sound.setLoop(false); // don't loop, we'll control playback
        sound.onEnded = () => {
          // Wait 5 seconds, then start another random track
          setTimeout(() => {
            playRandomBG();
          }, 5000);
        };
        sound.play();
      }
    }

    function restartLevel() { startLevel(currentLevel); }

    menu.addEventListener('click', (e) => {
      const btn = e.target.closest('button');
      if (!btn) return;
      const action = btn.getAttribute('data-action');
      if (action === 'start') {
        startNewGame(e);
      } else if (action === 'restart') {
        restartGame(e);
      }
    });

    function startNewGame(e) {
        e.preventDefault();
        menu.style.display = 'none';
        currentLevel = 0;
        startLevel(currentLevel);
    }

    function restartGame(e) {
        e.preventDefault();
        menu.style.display = 'none';
        startLevel(currentLevel);
    }

    // ------------ Camera (smoothed) ------------
    let camYaw = DEFAULT_CAM.yaw;
    let camPitch = DEFAULT_CAM.pitch;
    let camYawTarget = YAW_FROM_INDEX[dirIndex] + Math.PI;
    let camPitchTarget = camPitch;
    let camDist = DEFAULT_CAM.dist;
    let camDistTarget = camDist;

    // ------------ Input handling ------------
    document.addEventListener("keydown", (e) => {
      switch (e.key) {
        case "Enter":
          startNewGame(e);
          break;
        case "r":
        case "R":
          restartLevel(e);
          break;
        case ",": // camera rotate right
          dirIndex = (dirIndex + 1) % 4;
          updateCameraBehind();
          break;
        case ".": // camera rotate left
          dirIndex = (dirIndex + 3) % 4; // same as -1 mod 4
          updateCameraBehind();
          break;
        case "ArrowLeft":
        case "ArrowRight":
        case "ArrowDown":
        case "ArrowUp":
        case " ":
          moveHero(e.key);
          break;
      }
    });

    function moveHero(key) {
      let dir = new THREE.Vector3();

      if (key === "ArrowDown")  dir.set(-1, 0, 0);
      if (key === "ArrowUp") dir.set(1, 0, 0);
      if (key === "ArrowRight")  dir.set(0, 0, 1);
      if (key === "ArrowLeft")    dir.set(0, 0, -1);
      if (key === " ") dir.set(1,0,0);

      // 🔑 rotate relative to dirIndex (camera orientation)
      for (let i = 0; i < dirIndex; i++) {
        dir = new THREE.Vector3(-dir.z, 0, dir.x);
      }

      var targetPos = ballPos.clone().add(dir);
      if (key === " ") targetPos.addScaledVector(dir, 2); // space = reset to start

      for (const c of customs) {
        if (c.isBlocking(targetPos.x, targetPos.y , targetPos.z)) {
          return; // Movement blocked
        }
      }
      if (sounds.hero_step && !sounds.hero_step.isPlaying) {
        sounds.hero_step.play();
      }

      // then continue with your existing movement checks...
      //ballPos.add(dir);
      moveFrom.copy(ballPos);
      moveTo.copy(ballPos).add(dir);
      OK_FALL_Y = moveTo.y - 5; // allow falling up to 5 units down
      if (key === " ") moveTo.copy(ballPos).addScaledVector(dir, 2); // space = reset to start

      // Teleport if target has a teleporter
      for (const tele of teleporters) tele.checkTeleport(moveTo);

      // Ball roll axis
      window.__moveAxis = new THREE.Vector3(dir.z, 0, -dir.x).normalize();
      moveStartTime = performance.now();
      isMoving = true;
      moves++;

      // Keep camera behind the new direction while moving
      updateCameraBehind();
    };

    // Mouse look & wheel still allowed, but next key realigns the camera behind
    let dragging = false, lastX = 0, lastY = 0;
    window.addEventListener('mousedown', e => { dragging = true; lastX = e.clientX; lastY = e.clientY; });
    window.addEventListener('mouseup',   () => { dragging = false; });
    window.addEventListener('mousemove', e => {
      if (!dragging) return;
      const dx = e.clientX - lastX, dy = e.clientY - lastY;
      lastX = e.clientX; lastY = e.clientY;
      camYawTarget   += dx * 0.003;
      camPitchTarget += dy * 0.003;
      camPitchTarget = Math.max(-0.9, Math.min(0.9, camPitchTarget));
    });
    window.addEventListener('wheel', e => {
      camDistTarget += (e.deltaY > 0 ? 1 : -1) * 0.6;
      camDistTarget = Math.max(3, Math.min(12, camDistTarget));
    }, { passive: true });

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // ------------ Helpers ------------

    function findNearestTileY(ballX, ballY, ballZ, tiles) {
      let candidates = tiles.filter(t => Math.abs(t.position.x - ballX) < 0.1 && Math.abs(t.position.z - ballZ) < 0.1 && t.position.y <= ballY + 1);
      if (candidates.length === 0) return null;

      // Find the tile with closest y
      return candidates.reduce((nearest, tile) => {
          return Math.abs(tile.position.y - ballY) < Math.abs(nearest.position.y - ballY) ? tile : nearest;
      }, candidates[0]);
    }
    function findNearestLiftY(ballX, ballY, ballZ, lifts) {
      let candidates = lifts.filter(t => Math.abs(t.mesh.position.x - ballX) < 0.1 && Math.abs(t.mesh.position.z - ballZ) < 0.1 && t.mesh.position.y <= ballY + 1);
      if (candidates.length === 0) return null;

      // Find the tile with closest y
      return candidates.reduce((nearest, tile) => {
          return Math.abs(tile.mesh.position.y - ballY) < Math.abs(nearest.mesh.position.y - ballY) ? tile : nearest;
      }, candidates[0]);
    }

    function hasFloorBelow(x, y, z) {

      // Return only if nearest , interm of y
      var teleport = teleporters.find(t => t.checkIfExactlyOnEntry1(new THREE.Vector3(x, y, z)));
      if (teleport) return teleport.mesh1;
      teleport = teleporters.find(t => t.checkIfExactlyOnEntry2(new THREE.Vector3(x, y, z)));
      if (teleport) return teleport.mesh2;

      return findNearestTileY(x, y, z, tiles);
      /*
      var tile = tiles.find(t => Math.abs(t.position.x - x) < 0.1 && Math.abs(t.position.y + BALL_RADIUS - y) < 0.1 && Math.abs(t.position.z - z) < 0.1);
      if (tile) return tile; // found exact match

      return tiles.find(t => Math.abs(t.position.x - x) < 0.1 && ((y+1) > t.position.y) && Math.abs(t.position.z - z) < 0.1);
      */
    }

    // ------------ Main loop ------------
    let lastTime = performance.now();
    function animate() {
      requestAnimationFrame(animate);
      // Torch flicker effect for goal light
      if (goalLight) {
        goalLight.intensity = 4.5 + Math.sin(Date.now() * 0.02) * 0.5 + (Math.random() - 0.5) * 0.3;

        const glowMesh = goalLight.getObjectByName("goalGlowMesh");
        if (glowMesh) {
          glowMesh.material.opacity = 0.5 + Math.sin(Date.now() * 0.01) * 0.3;
        }
      }
      const now = performance.now();
      const dt = now - lastTime;
      lastTime = now;

      if (gameRunning) {
        for (const l of lifts) l.update(dt);
        for (const g of ghosts) g.update(dt);

        // Update false floors
        for (let i = falseFloors.length - 1; i >= 0; i--) {
          if (falseFloors[i].update(ballPos)) {
            falseFloors.splice(i, 1);
          }
        }
      }

      if (isMoving && !falling) {
        const t = Math.min(1, (now - moveStartTime) / ( (0.5 / MOVE_SPEED) * 1000 ));
        ballPos.lerpVectors(moveFrom, moveTo, t);

        // Snap to lift if we move over it
        ridingLift = findNearestLiftY(ballPos.x, ballPos.y, ballPos.z, lifts);

        // Ball visual rolling
        const dist = TILE_SIZE * t;
        const angle = dist / BALL_RADIUS;
        ball.rotation.set(0,0,0);
        ball.rotateOnWorldAxis(window.__moveAxis || new THREE.Vector3(0,0,0), angle);

        if (t >= 1) {
          isMoving = false;
          ballPos.copy(moveTo);

          if (!ridingLift) {
            // Check if we can drop onto a floor tile, from upwards lift
            const tx = Math.round(ballPos.x), ty = Math.round(ballPos.y), tz = Math.round(ballPos.z);
            const belowTile = hasFloorBelow(tx, ty, tz);
            if (belowTile) {
              ballPos.x = tx; ballPos.z = tz;
              dropStartY = belowTile.position.y + BALL_RADIUS;
              dropStartTime = performance.now();
              falling = false;
            } else {
              falling = true; velocityY = 0;
            }
          }
          if (goalActive && ballPos.distanceTo(GOAL_POS) < 0.5) {
            winGame();
          }
        }
      }

      if (falling) {
        if (sounds.drop && !sounds.drop.isPlaying) {
          sounds.drop.play();
        }
        velocityY -= 0.015;
        ballPos.y += velocityY;
        if (ballPos.y < OK_FALL_Y) {
          if (sounds.drop_break) {
            sounds.drop_break.play();
          }
          loseGame("You Fell");
        }
      } else if (!isMoving) {
        if (ridingLift) {
          if (landStartY !== null) {
            const elapsed = performance.now() - landStartTime;
            const t = Math.min(1, elapsed / LAND_DURATION);
            ballPos.y = landStartY + (landTargetY - landStartY) * t;
            ballPos.x = ridingLift.mesh.position.x;
            ballPos.z = ridingLift.mesh.position.z;
            if (t >= 1) landStartY = null;
          } else {
            ballPos.set(ridingLift.mesh.position.x,
                        ridingLift.mesh.position.y + BALL_RADIUS,
                        ridingLift.mesh.position.z);
          }
          dropStartY = null;
        } else {
          if (dropStartY === null) { dropStartY = ballPos.y + BALL_RADIUS; dropStartTime = performance.now(); }
          const elapsed = performance.now() - dropStartTime;
          const t = Math.min(1, elapsed / DROP_DURATION);
          ballPos.y = dropStartY;
          ballPos.x = Math.round(ballPos.x);
          ballPos.z = Math.round(ballPos.z);
        }
      }

      // Apply camera smoothing
      camYaw += (camYawTarget - camYaw) * CAM_SMOOTH;
      camPitch += (camPitchTarget - camPitch) * CAM_SMOOTH;
      camDist += (camDistTarget - camDist) * CAM_SMOOTH;
      const cx = ballPos.x + Math.cos(camYaw) * Math.cos(camPitch) * camDist;
      const cy = ballPos.y + Math.sin(camPitch) * camDist + 1;
      const cz = ballPos.z + Math.sin(camYaw) * Math.cos(camPitch) * camDist;
      camera.position.set(cx, cy, cz);
      camera.lookAt(ballPos.x, ballPos.y, ballPos.z);

      ball.position.copy(ballPos);
      // ✅ Continuous crystal check
      for (const c of crystals) { c.checkCollect(ballPos); }
      renderer.render(scene, camera);
    }
    animate();

    // Controls

    const controlDiv = document.getElementById("control");
    if (!controlDiv) return;

    controlDiv.innerHTML = `
      <b>Controls:</b><br>
      ↑ ↓ ← → : Move<br>
      &lt; / &gt; : Rotate Camera<br>
      R : Restart<br>
      Enter : New Game <br>
      Theme:
      <select id="themeSelect">
        <option value="">Select Theme</option>
        <option value="desert">Desert</option>
        <option value="forest">Forest</option>
        <option value="rocks">Rocks</option>
        <option value="full">Full</option>
      </select>
      Level:
      <select id="levelSelect"></select>
    `;

    const themeSelect = document.getElementById("themeSelect");
    const levelSelect = document.getElementById("levelSelect");

    // Repopulate level dropdown
    function refreshLevelSelect() {
      if (!levels) return;
      levelSelect.innerHTML = "";
      levels.forEach((lvl, i) => {
        const opt = document.createElement("option");
        opt.value = i;
        opt.textContent = `Level ${i+1}`;
        if (i === currentLevel) opt.selected = true;
        levelSelect.appendChild(opt);
      });
    }

    // Handle theme change
    themeSelect.addEventListener("change", async () => {
      const theme = themeSelect.value;
      try {
        const res = await fetch(`levels/${theme}_detailed.json`);
        const json = await res.json();
        levels.length = 0;
        json.forEach(l => levels.push(l));
        currentLevel = 0;
        refreshLevelSelect();
        startLevel(currentLevel);
      } catch (err) {
        console.error("Failed to load theme:", err);
      }
    });

    // Handle level change
    levelSelect.addEventListener("change", () => {
      currentLevel = parseInt(levelSelect.value, 10);
      startLevel(currentLevel);
    });

    const select = document.getElementById('themeSelect');
    // Set its value
    select.value = 'full';
    // Trigger the change event
    const event = new Event('change', { bubbles: true });
    select.dispatchEvent(event);
    // Initialize
    refreshLevelSelect();

    // Background music
    loadSound("bg_forest_1", "bg_forest_1.wav", true, 0.4);
    loadSound("bg_forest_2", "bg_forest_2.wav", true, 0.4);
    loadSound("bg_forest_3", "bg_forest_3.wav", true, 0.4);

    // Hero / Ball
    loadSound("hero_step", "hero_step.wav", false, 0.6);
    loadSound("drop", "drop.wav");
    loadSound("drop_break", "drop_break.wav");

    // Collectibles
    loadSound("crystall", "crystall.wav");

    // Hazards
    loadSound("falsefloor", "falsefloor.wav");

    // Enemies footsteps
    loadSound("ghost_step", "ghost_step.wav");

    // Game events
    loadSound("exit", "exit.wav");
    loadSound("gameover", "gameover.wav");
    loadSound("gamecomplete", "gamecomplete.wav");
    loadSound("death", "death.wav");

    // UI
    loadSound("change", "change.wav");
    loadSound("choose", "choose.wav");

  })();
  </script>
</body>
</html>
