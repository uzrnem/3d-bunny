<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Ball Rolling Game</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; }
    canvas { display: block; }
    #hud {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      font-family: sans-serif;
      background: rgba(0,0,0,0.5);
      padding: 8px;
      border-radius: 8px;
      user-select:none;
    }
    #menu {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      display: flex; align-items: center; justify-content: center; flex-direction: column;
      background: rgba(0,0,0,0.8);
      color: white; font-family: sans-serif; z-index: 10;
    }
    button { margin-top: 12px; padding: 10px 20px; font-size: 16px; border-radius: 6px; border: none; cursor: pointer; }
  </style>
</head>
<body>
  <div id="hud">Moves: 0 | Time: 0s<br>Best Moves: - | Best Time: -</div>
  <div id="menu"><h1>Ball Rolling Game</h1><button id="startBtn">Start Game</button></div>
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
  <script>
  (() => {
    // ===== Constants =====
    const TILE_SIZE = 1;
    const TILE_HEIGHT = 0.1;        // BoxGeometry height
    const BALL_RADIUS = 0.3;
    const BALL_Y = 0 + BALL_RADIUS; // top of tile is y=0, keep ball center above tile

    const MOVE_SPEED = 3;           // tiles per second
    const CAM_SMOOTH = 0.12;        // camera lerp factor

    // ===== Basic Setup =====
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // ===== Skybox Background =====
    const loader = new THREE.CubeTextureLoader();
    const skybox = loader.load([
      './bg_front.bmp',
      './bg_back.bmp',
      './bg_top.bmp',
      './bg_bottom.bmp',
      './bg_right.bmp',
      './bg_left.bmp'
    ]);
    scene.background = skybox;

    // ===== Tiles =====
    const tileGeo = new THREE.BoxGeometry(TILE_SIZE, TILE_HEIGHT, TILE_SIZE);
    const tileMat = new THREE.MeshStandardMaterial({ color: 0x444444 });
    const tiles = [];
    for (let x = 0; x < 16; x++) {
      for (let z = 0; z < 16; z++) {
        const tile = new THREE.Mesh(tileGeo, tileMat);
        tile.position.set(x, -TILE_HEIGHT/2, z);
        scene.add(tile);
        tiles.push(tile);
      }
    }
    // Start & Goal tiles
    const startTile = new THREE.Mesh(tileGeo, new THREE.MeshStandardMaterial({ color: 0x2255ff }));
    startTile.position.set(-1, -TILE_HEIGHT/2, 0);
    scene.add(startTile); tiles.push(startTile);

    const startTile1 = new THREE.Mesh(tileGeo, new THREE.MeshStandardMaterial({ color: 0x444444 }));
    startTile1.position.set(-1, -TILE_HEIGHT/2, 15);
    scene.add(startTile1); tiles.push(startTile1);
    
    const startTile2 = new THREE.Mesh(tileGeo, new THREE.MeshStandardMaterial({ color: 0x444444 }));
    startTile2.position.set(0, -TILE_HEIGHT/2, -1);
    scene.add(startTile2); tiles.push(startTile2);

    const startTile3 = new THREE.Mesh(tileGeo, new THREE.MeshStandardMaterial({ color: 0x444444 }));
    startTile2.position.set(15, -TILE_HEIGHT/2, -1);
    scene.add(startTile2); tiles.push(startTile3);

    const goalTile = new THREE.Mesh(tileGeo, new THREE.MeshStandardMaterial({ color: 0x22ff55 }));
    goalTile.position.set(15, -TILE_HEIGHT/2, 15);
    scene.add(goalTile); tiles.push(goalTile);

    // ===== Ball =====
    const ballGeo = new THREE.SphereGeometry(BALL_RADIUS, 32, 32);
    const ballMat = new THREE.MeshStandardMaterial({ color: 0xff2222 });
    const ball = new THREE.Mesh(ballGeo, ballMat);
    scene.add(ball);

    // ===== Lighting =====
    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(5, 10, 5);
    scene.add(dirLight);

    // ===== Game State =====
    const START_POS = new THREE.Vector3(-1, BALL_Y, 0);
    const GOAL_POS  = new THREE.Vector3( 5, BALL_Y, 5);
    let ballPos = START_POS.clone();
    let moves = 0;
    let startTime = 0;
    let timerId;
    let bestMoves = Number(localStorage.getItem('bestMoves')) || null;
    let bestTime  = Number(localStorage.getItem('bestTime'))  || null;

    // Falling physics
    let velocityY = 0;
    let falling = false;

    // Smooth tile-to-tile movement + rolling
    let isMoving = false;
    let moveFrom = new THREE.Vector3();
    let moveTo   = new THREE.Vector3();
    let moveDir  = new THREE.Vector3();
    let moveAxis = new THREE.Vector3(); // rotation axis for rolling
    let moveStartTime = 0;
    let moveDuration  = 1 / MOVE_SPEED; // seconds to move 1 tile

    // Camera orbit (mouse driven with smoothing)
    let camYaw   = Math.PI * 0.25 - Math.PI/2 - Math.PI/4; // initial yaw rotated -135 degrees
    let camPitch = 0.35;           // radians, up/down
    let camYawTarget = camYaw;
    let camPitchTarget = camPitch;
    let camDist = 6;
    let camDistTarget = camDist;

    const hud  = document.getElementById('hud');
    const menu = document.getElementById('menu');
    const startBtn = document.getElementById('startBtn');

    function updateHUD() {
      const t = Math.floor((Date.now() - startTime) / 1000);
      hud.innerHTML = `Moves: ${moves} | Time: ${t}s<br>Best Moves: ${bestMoves ?? '-'} | Best Time: ${bestTime ? bestTime + 's' : '-'}`;
    }

    function resetGame() {
      ballPos.copy(START_POS);
      ball.position.copy(ballPos);
      ball.rotation.set(0,0,0);
      velocityY = 0;
      falling = false;
      isMoving = false;
      moves = 0;
      startTime = Date.now();
      updateHUD();
    }

    function winGame() {
      clearInterval(timerId);
      const duration = Math.floor((Date.now() - startTime) / 1000);
      let newRecord = "";
      if (!bestMoves || moves < bestMoves) { bestMoves = moves; localStorage.setItem('bestMoves', bestMoves); newRecord += "New Record: Fewest Moves! "; }
      if (!bestTime  || duration < bestTime) { bestTime  = duration; localStorage.setItem('bestTime',  bestTime ); newRecord += "New Record: Fastest Time!"; }
      menu.style.display = 'flex';
      menu.innerHTML = `<h1>You Win!</h1><p>Moves: ${moves}, Time: ${duration}s</p><p>${newRecord}</p><button onclick=\"location.reload()\">Restart</button>`;
    }

    function loseGame() {
      clearInterval(timerId);
      menu.style.display = 'flex';
      menu.innerHTML = `<h1>You Fell!</h1><button onclick=\"location.reload()\">Restart</button>`;
    }

    function isTileAt(x, z) {
      return tiles.some(t => Math.abs(t.position.x - x) < 0.1 && Math.abs(t.position.z - z) < 0.1);
    }

    // ===== Input Handling =====
    window.addEventListener('keydown', e => {
      // Reset camera angle on ANY key press (to initial orientation)
      camYawTarget = Math.PI * 0.25 - Math.PI/2 - Math.PI/4;
      camPitchTarget = 0.35;
      camDistTarget = 6;

      if (!['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)) return;

      e.preventDefault();
      if (isMoving || falling) return;

      const dir = new THREE.Vector3();
      if (e.key === 'ArrowUp')    dir.set(1, 0, 0);
      if (e.key === 'ArrowDown')  dir.set(-1, 0, 0);
      if (e.key === 'ArrowLeft')  dir.set(0, 0, -1);
      if (e.key === 'ArrowRight') dir.set(0,0, 1);

      moveFrom.copy(ballPos);
      moveTo.copy(ballPos).add(dir);
      moveDir.copy(dir);
      moveAxis.set(dir.z, 0, -dir.x).normalize();

      moveStartTime = performance.now();
      isMoving = true;
      moves++;
    });

    // Mouse orbit controls (simple, with damping)
    let dragging = false;
    let lastX = 0, lastY = 0;
    window.addEventListener('mousedown', (e) => { dragging = true; lastX = e.clientX; lastY = e.clientY; });
    window.addEventListener('mouseup',   () => { dragging = false; });
    window.addEventListener('mousemove', (e) => {
      if (!dragging) return;
      const dx = e.clientX - lastX;
      const dy = e.clientY - lastY;
      lastX = e.clientX; lastY = e.clientY;
      camYawTarget   += dx * 0.003;
      camPitchTarget += dy * 0.003;
      camPitchTarget = Math.max(-0.9, Math.min(0.9, camPitchTarget));
    });
    window.addEventListener('wheel', (e) => {
      camDistTarget += (e.deltaY > 0 ? 1 : -1) * 0.6;
      camDistTarget = Math.max(3, Math.min(12, camDistTarget));
    }, { passive: true });

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    function animate() {
      requestAnimationFrame(animate);
      const now = performance.now();

      if (isMoving && !falling) {
        const t = Math.min(1, (now - moveStartTime) / (moveDuration * 1000));
        ballPos.lerpVectors(moveFrom, moveTo, t);
        ballPos.y = BALL_Y;
        const dist = TILE_SIZE * t;
        const angle = dist / BALL_RADIUS;
        ball.rotation.setFromVector3(new THREE.Vector3(0,0,0));
        ball.rotateOnWorldAxis(moveAxis, angle);

        if (t >= 1) {
          isMoving = false;
          ballPos.copy(moveTo);
          if (ballPos.x === GOAL_POS.x && ballPos.z === GOAL_POS.z) {
            winGame();
          } else if (!isTileAt(ballPos.x, ballPos.z)) {
            falling = true;
            velocityY = 0;
          }
        }
      }

      if (falling) {
        velocityY -= 0.015;
        ballPos.y += velocityY;
        if (ballPos.y < -5) loseGame();
      } else if (!isMoving) {
        ballPos.y = BALL_Y;
      }

      ball.position.copy(ballPos);

      camYaw   += (camYawTarget   - camYaw)   * CAM_SMOOTH;
      camPitch += (camPitchTarget - camPitch) * CAM_SMOOTH;
      camDist  += (camDistTarget  - camDist)  * CAM_SMOOTH;

      const cosP = Math.cos(camPitch), sinP = Math.sin(camPitch);
      const offset = new THREE.Vector3(
        Math.sin(camYaw) * cosP,
        sinP,
        Math.cos(camYaw) * cosP
      ).multiplyScalar(camDist);

      const desiredCamPos = ball.position.clone().add(offset);
      camera.position.lerp(desiredCamPos, CAM_SMOOTH);
      camera.lookAt(ball.position);

      updateHUD();
      renderer.render(scene, camera);
    }

    startBtn.onclick = () => {
      menu.style.display = 'none';
      resetGame();
      clearInterval(timerId);
      timerId = setInterval(updateHUD, 1000);
    };

    ball.position.copy(ballPos);
    const initOffset = new THREE.Vector3(0, camDist, camDist);
    camera.position.copy(ball.position.clone().add(initOffset));
    camera.lookAt(ball.position);

    animate();
    updateHUD();
  })();
  </script>
</body>
</html>
