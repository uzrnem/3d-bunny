<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Ball Rolling Game</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; }
    canvas { display: block; }
    #hud {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      background: rgba(0,0,0,0.5);
      padding: 8px 10px;
      border-radius: 8px;
      user-select:none;
      line-height: 1.3;
    }
    #control {
      position: absolute;
      top: 70px;
      left: 10px;
      color: white;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      background: rgba(0,0,0,0.5);
      padding: 8px 10px;
      border-radius: 8px;
      user-select:none;
      line-height: 1.3;
    }
    #menu {
      position: absolute;
      inset: 0;
      display: flex; align-items: center; justify-content: center; flex-direction: column;
      background: rgba(0,0,0,0.8);
      color: white; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      z-index: 10;
    }
    button { margin-top: 12px; padding: 10px 20px; font-size: 16px; border-radius: 6px; border: none; cursor: pointer; }
  </style>
</head>
<body>
  <div id="hud">Moves: 0 | Time: 0s<br>Best Moves: - | Best Time: -</div>
  <div id="control"></div>
  <div id="menu"><h1>Ball Rolling Game</h1><button data-action="start">Start Game</button></div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
  <script>
  (() => {
    const TILE_SIZE = 1;
    const TILE_HEIGHT = 0.1;
    const BALL_RADIUS = 0.4;

    const MOVE_SPEED = 3; // Ball speed in tiles per second
    const CAM_SMOOTH = 0.12;
    const LIFT_SPEED = 2.0;
    const LIFT_PAUSE_MS = 2000;
    const DROP_DURATION = 200;
    const LAND_DURATION = 200;

    const DEFAULT_CAM = {
      yaw: Math.PI, // * 0.75, // + , // - Math.PI/4, // - Math.PI/4,
      pitch: 0.35,
      dist: 6
    };

    // ------------ Levels ------------
    const levels = [
      {
        "elements": [
          {"type":"floor","from":{"x":0,"y":0,"z":0},"to":{"x":15,"y":0,"z":15}},
          {"type":"hero","position":{"x":-1,"y":0,"z":0}},
          {"type":"floor","position":{"x":-1,"y":0,"z":15}},
          {"type":"floor","position":{"x":0,"y":0,"z":-1}},
          {"type":"floor","position":{"x":15,"y":0,"z":-1}},
          {"type":"goal","position":{"x":15,"y":0,"z":15}},
          {"type":"lift","from":{"x":-1,"y":0,"z":1},"to":{"x":-1,"y":0,"z":14}},
          {"type":"lift","from":{"x":1,"y":0,"z":-1},"to":{"x":14,"y":0,"z":-1}},
          {"type":"lift","from":{"x":-1,"y":0,"z":-1},"to":{"x":15,"y":15,"z":15}},
          {"type":"lift","from":{"x":16,"y":0,"z":-1},"to":{"x":16,"y":0,"z":15}},
          {"type":"lift","from":{"x":-2,"y":0,"z":0},"to":{"x":-2,"y":-15,"z":0}},
          {"type":"teleporter","entry1":{"x":2,"y":0,"z":2},"entry2":{"x":13,"y":0,"z":13}},
          {"type":"stair","position":{"x":16,"y":1,"z":1},"direction":"right","count":"6"},
          {"type":"floor","position":{"x":0,"y":0,"z":-2}},
          {"type":"stair","position":{"x":1,"y":0,"z":-2},"direction":"right","count":"6"},
          {"type":"bonuscrystall","position":{"x":8,"y":0,"z":9}},
          {"type":"bonuscrystall","position":{"x":8,"y":0,"z":7}}
        ]
      },
      {
        "levelNumber": 2,
        "defaultTime": 80,
        "instructions": [
          "Welcome to Magic Forest!",
          "Your first task is to collect all the ",
          "crystals and find the exit to the next level.",
          "Tip: To zoom-in, use key 'A', to zoom-out use key 'Z'.",
          "Good Luck!"
        ],
        "elements": [
          {
            "type": "hero",
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "facing": "back"
          },
          {
            "type": "floor",
            "from": {
              "x": -3,
              "y": 0,
              "z": 2
            },
            "to": {
              "x": 3,
              "y": 0,
              "z": -2
            }
          },
          {
            "type": "floor",
            "from": {
              "x": 4,
              "y": 0,
              "z": 0
            },
            "to": {
              "x": 5,
              "y": 0,
              "z": 0
            }
          },
          {
            "type": "floor",
            "from": {
              "x": 6,
              "y": 0,
              "z": 1
            },
            "to": {
              "x": 10,
              "y": 0,
              "z": -1
            }
          },
          {
            "type": "floor",
            "from": {
              "x": 8,
              "y": 0,
              "z": 2
            },
            "to": {
              "x": 10,
              "y": 0,
              "z": 5
            }
          },
          {
            "type": "floor",
            "from": {
              "x": 9,
              "y": 0,
              "z": 7
            },
            "to": {
              "x": 6,
              "y": 0,
              "z": 7
            }
          },
          {
            "type": "floor",
            "from": {
              "x": 2,
              "y": 0,
              "z": 3
            },
            "to": {
              "x": 2,
              "y": 0,
              "z": 4
            }
          },
          {
            "type": "floor",
            "from": {
              "x": 1,
              "y": 0,
              "z": 5
            },
            "to": {
              "x": 5,
              "y": 0,
              "z": 7
            }
          },
          {
            "type": "floor",
            "from": {
              "x": -4,
              "y": 0,
              "z": 0
            },
            "to": {
              "x": -5,
              "y": 0,
              "z": 0
            }
          },
          {
            "type": "floor",
            "from": {
              "x": -6,
              "y": 0,
              "z": 1
            },
            "to": {
              "x": -10,
              "y": 0,
              "z": -1
            }
          },
          {
            "type": "floor",
            "from": {
              "x": -10,
              "y": 0,
              "z": -2
            },
            "to": {
              "x": -8,
              "y": 0,
              "z": -5
            }
          },
          {
            "type": "floor",
            "from": {
              "x": -7,
              "y": 0,
              "z": -4
            },
            "to": {
              "x": -2,
              "y": 0,
              "z": -4
            }
          },
          {
            "type": "floor",
            "position": {
              "x": 9,
              "y": 0,
              "z": 6
            }
          },
          {
            "type": "floor",
            "position": {
              "x": -2,
              "y": 0,
              "z": -3
            }
          },
          {
            "type": "bonuscrystall",
            "position": {
              "x": 2,
              "y": 0,
              "z": 1
            }
          },
          {
            "type": "bonuscrystall",
            "position": {
              "x": 2,
              "y": 0,
              "z": -1
            }
          },
          {
            "type": "bonuscrystall",
            "position": {
              "x": -2,
              "y": 0,
              "z": -1
            }
          },
          {
            "type": "bonuscrystall",
            "position": {
              "x": -2,
              "y": 0,
              "z": 1
            }
          },
          {
            "type": "bonuscrystall",
            "position": {
              "x": 9,
              "y": 0,
              "z": 0
            }
          },
          {
            "type": "bonuscrystall",
            "position": {
              "x": 9,
              "y": 0,
              "z": 2
            }
          },
          {
            "type": "bonuscrystall",
            "position": {
              "x": 9,
              "y": 0,
              "z": 4
            }
          },
          {
            "type": "bonuscrystall",
            "position": {
              "x": -9,
              "y": 0,
              "z": 0
            }
          },
          {
            "type": "bonuscrystall",
            "position": {
              "x": -9,
              "y": 0,
              "z": -2
            }
          },
          {
            "type": "bonuscrystall",
            "position": {
              "x": -9,
              "y": 0,
              "z": -4
            }
          },
          {
            "type": "custom",
            "position": {
              "x": 3,
              "y": 0,
              "z": 2
            },
            "comment": "tree01.x"
          },
          {
            "type": "custom",
            "position": {
              "x": 3,
              "y": 0,
              "z": -2
            },
            "comment": "tree02.x"
          },
          {
            "type": "custom",
            "position": {
              "x": -3,
              "y": 0,
              "z": -2
            },
            "comment": "tree01.x"
          },
          {
            "type": "custom",
            "position": {
              "x": -3,
              "y": 0,
              "z": 2
            },
            "comment": "tree03.x"
          },
          {
            "type": "custom",
            "position": {
              "x": -9,
              "y": 0,
              "z": -3
            },
            "comment": "barrel.x"
          },
          {
            "type": "custom",
            "position": {
              "x": 4,
              "y": 0,
              "z": 6
            },
            "comment": "barrel.x"
          },
          {
            "type": "goal",
            "position": {
              "x": 2,
              "y": 0,
              "z": 6
            }
          }
        ]
      }
    ];
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const loader = new THREE.CubeTextureLoader();
    const skybox = loader.load([
      './bg/bg_front.bmp',
      './bg/bg_back.bmp',
      './bg/bg_top.bmp',
      './bg/bg_bottom.bmp',
      './bg/bg_right.bmp',
      './bg/bg_left.bmp'
    ]);
    scene.background = skybox;

    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(5, 10, 5);
    scene.add(dirLight);

    // Load Texture
    const tilesTextureLoader = new THREE.TextureLoader();
    const tileTexture = tilesTextureLoader.load("./bg/tiles.png"); // <-- replace with your file path
    const falseFloorTexture = tilesTextureLoader.load("./bg/falsefloor.png"); // <-- replace with your file path
    const goalTexture = tilesTextureLoader.load("./bg/goal.png"); // <-- replace with your file path
    const destinationTexture = tilesTextureLoader.load("./bg/destination.png"); // <-- replace with your file path
    const diamondTexture = tilesTextureLoader.load("./bg/diamond.png"); // <-- replace with your file path
    const liftTexture = tilesTextureLoader.load("./bg/lift.png"); // <-- replace with your file path
    const teleportTexture = tilesTextureLoader.load("./bg/teleport.png"); // <-- replace with your file path
    const ballTexture = tilesTextureLoader.load("./bg/ball.png"); // <-- replace with your file path

    const tileGeo = new THREE.BoxGeometry(TILE_SIZE, TILE_HEIGHT, TILE_SIZE);
    const ballGeo = new THREE.SphereGeometry(BALL_RADIUS, 32, 32);

    const tileMat  = new THREE.MeshBasicMaterial({ map: tileTexture });
    const falseMat  = new THREE.MeshBasicMaterial({ map: falseFloorTexture });
    const goalMat  = new THREE.MeshBasicMaterial({ map: goalTexture });
    const destinationMat  = new THREE.MeshBasicMaterial({ map: destinationTexture });
    const liftMat  = new THREE.MeshBasicMaterial({ map: liftTexture });
    const teleportMat  = new THREE.MeshBasicMaterial({ map: teleportTexture });
    const crystallMat  = new THREE.MeshBasicMaterial({ map: diamondTexture });
    const ballMat  = new THREE.MeshBasicMaterial({ map: ballTexture });

    let tiles = [];
    let lifts = [];
    let falseFloors = [];
    let teleporters = [];
    let crystals = [];
    let crystalsRemaining = 0;
    let goalActive = false;
    let startTile, goalTile;
    let START_POS, GOAL_POS;

    const ball = new THREE.Mesh(ballGeo, ballMat);
    scene.add(ball);

    // ------------ Moving platforms, teleporter, crystals ------------
    class Lift {
      constructor(x1,y1,z1,x2,y2,z2) {
        this.start = new THREE.Vector3(x1,y1,z1);
        this.end   = new THREE.Vector3(x2,y2,z2);
        this.progress = 0;
        this.forward = true;
        this.waitUntil = 0;
        this.distance = this.start.distanceTo(this.end);
        this.travelTime = Math.max(0.0001, this.distance / LIFT_SPEED);
        this.mesh = new THREE.Mesh(tileGeo, liftMat);
        scene.add(this.mesh);
        this.mesh.position.copy(this.start);
      }
      update(dtMs) {
        if (Date.now() < this.waitUntil) return;
        const delta = dtMs / (this.travelTime * 1000);
        this.progress += this.forward ? delta : -delta;
        if (this.progress >= 1) { this.progress = 1; this.forward = false; this.waitUntil = Date.now() + LIFT_PAUSE_MS; }
        if (this.progress <= 0) { this.progress = 0; this.forward = true;  this.waitUntil = Date.now() + LIFT_PAUSE_MS; }
        this.mesh.position.lerpVectors(this.start, this.end, this.progress);
      }
      reset() { this.progress = 0; this.forward = true; this.waitUntil = 0; this.mesh.position.copy(this.start); }
      dispose() { scene.remove(this.mesh); }
    }

    class Teleporter {
      constructor(e1, e2) {
        this.entry1 = new THREE.Vector3(e1.x, e1.y/3, e1.z);
        this.entry2 = new THREE.Vector3(e2.x, e2.y/3, e2.z);
        this.mesh1 = new THREE.Mesh(tileGeo, teleportMat);
        this.mesh2 = new THREE.Mesh(tileGeo, teleportMat);
        this.mesh1.position.set(e1.x, e1.y/3-TILE_HEIGHT/2, e1.z);
        this.mesh2.position.set(e2.x, e2.y/3-TILE_HEIGHT/2, e2.z);
        scene.add(this.mesh1);
        scene.add(this.mesh2);
      }
      checkTeleport(pos) {
        if (Math.abs(pos.x - this.entry1.x) < 0.1 && this.entry1.distanceTo(pos) < 0.5 && Math.abs(pos.z - this.entry1.z) < 0.1) {
          pos.copy(this.entry2);
        } else if (Math.abs(pos.x - this.entry2.x) < 0.1 && this.entry2.distanceTo(pos) < 0.5 && Math.abs(pos.z - this.entry2.z) < 0.1) {
          pos.copy(this.entry1);
        }
      }
      dispose() {
        scene.remove(this.mesh1);
        scene.remove(this.mesh2);
      }
    }

    class BonusCrystall {
      constructor(pos) {
        // place crystal just above floor (y/3 for tiles) plus some lift for visibility
        const y = pos.y / 3 + .5;  
        this.pos = new THREE.Vector3(pos.x, y, pos.z);

        const geo = new THREE.OctahedronGeometry(0.3);
        this.mesh = new THREE.Mesh(geo, crystallMat);
        this.mesh.position.copy(this.pos);
        scene.add(this.mesh);

        this.collected = false;
      }
      checkCollect(ballPos) {
        if (this.collected) return false;

        // Check same tile (x and z match exactly)
        if (ballPos.x === this.pos.x && ballPos.z === this.pos.z) {
          //console.log("Ball position:", ballPos, "Crystal position:", this.pos, " y difference: ball: ", ballPos.y,  "crystal: ",this.pos.y);
          // Check vertical closeness
          if (Math.abs(ballPos.y - this.pos.y) < 2) {
            this.collected = true;
            scene.remove(this.mesh);
            crystalsRemaining--;

            if (crystalsRemaining <= 0) {
              goalTile.material = destinationMat;
              goalActive = true;
            }
            return true;
          }
        }
        return false;
      }
      dispose() { scene.remove(this.mesh); }
    }

    class FalseFloor {
      constructor(pos) {
        this.pos = new THREE.Vector3(pos.x, pos.y/3, pos.z);
        this.mesh = new THREE.Mesh(tileGeo, falseMat);
        this.mesh.position.set(this.pos.x, this.pos.y - TILE_HEIGHT/2, this.pos.z);
        scene.add(this.mesh);
        this.triggered = false;
        this.removeAt = null;
      }

      update(ballPos) {
        if (this.triggered || !ballPos) return;
        if (
          Math.abs(ballPos.x - this.pos.x) < 0.1 &&
          Math.abs(ballPos.z - this.pos.z) < 0.1 &&
          Math.abs(ballPos.y - (this.pos.y + BALL_RADIUS)) < 0.2
        ) {
          this.triggered = true;
          this.removeAt = Date.now() + 3000; // 3 sec countdown
        }
      }

      animate() {
        if (!this.triggered) return;

        const timeLeft = this.removeAt - Date.now();
        if (timeLeft <= 0) return;

        // Crack effect: pulse color + shake scale
        const t = (3000 - timeLeft) / 3000; // 0 → 1 progress
        const intensity = Math.sin(Date.now() * 0.02 * (1 + t * 5)); // faster near the end

        // Flash between red & black
        this.mesh.material.color.setRGB(0.5 + 0.5 * intensity, 0, 0);

        // Tiny shake in scale
        const scale = 1 + 0.05 * intensity;
        this.mesh.scale.set(scale, 1, scale);
      }

      checkRemove(ballPos) {
        if (this.triggered && Date.now() >= this.removeAt) {
          // Start falling instead of disappearing instantly
          if (!this.falling) {
            this.falling = true;
            this.fallSpeed = 0;

            // Remove from tiles[] so it no longer counts as ground
            const idx = tiles.indexOf(this.mesh);
            if (idx !== -1) tiles.splice(idx, 1);

            // If the ball is on top of this tile → make ball fall immediately
            if (
              Math.abs(ballPos.x - this.pos.x) < 0.1 &&
              Math.abs(ballPos.z - this.pos.z) < 0.1
            ) {
              falling = true;
              velocityY = 0; // reset ball velocity
            }
          }
        }

        if (this.falling) {
          this.fallSpeed -= 0.02; // gravity
          this.mesh.position.y += this.fallSpeed;

          // Remove after it falls below the world
          if (this.mesh.position.y < -5) {
            scene.remove(this.mesh);
            this.mesh.geometry.dispose();
            this.mesh.material.dispose();
            return true;
          }
        }
        return false;
      }

      dispose() { scene.remove(this.mesh); }
    }



    // ------------ Level loading ------------
    function loadLevel(index) {
      tiles.forEach(t => scene.remove(t));
      lifts.forEach(l => l.dispose && l.dispose());
      falseFloors.forEach(f => f.dispose());
      teleporters.forEach(t => t.dispose());
      crystals.forEach(c => c.dispose());
      if (startTile) scene.remove(startTile);
      if (goalTile)  scene.remove(goalTile);
      tiles = [];
      lifts = [];
      falseFloors = [];
      teleporters = [];
      crystals = [];
      crystalsRemaining = 0;
      goalActive = false;
      startTile = goalTile = undefined;
      START_POS = GOAL_POS = undefined;

      const def = levels[index].elements;
      def.forEach(obj => {
        if (obj.type === "floor") {
          if (obj.from && obj.to) {
            const minX = Math.min(obj.from.x, obj.to.x);
            const maxX = Math.max(obj.from.x, obj.to.x);
            const minY = Math.min(obj.from.y, obj.to.y);
            const minZ = Math.min(obj.from.z, obj.to.z);
            const maxZ = Math.max(obj.from.z, obj.to.z);

            for (let x = minX; x <= maxX; x++) {
              for (let z = minZ; z <= maxZ; z++) {
                const t = new THREE.Mesh(tileGeo, tileMat);
                t.position.set(x, minY/3-TILE_HEIGHT/2, z);
                scene.add(t); tiles.push(t);
              }
            }
          } else {
            const t = new THREE.Mesh(tileGeo, tileMat);
            t.position.set(obj.position.x, obj.position.y/3-TILE_HEIGHT/2, obj.position.z);
            scene.add(t); tiles.push(t);
          }
        } else if (obj.type === "hero") {
          startTile = new THREE.Mesh(tileGeo, tileMat);
          startTile.position.set(obj.position.x, obj.position.y/3-TILE_HEIGHT/2, obj.position.z);
          scene.add(startTile); tiles.push(startTile);
          START_POS = new THREE.Vector3(obj.position.x, obj.position.y/3, obj.position.z);
        } else if (obj.type === "goal") {
          goalTile = new THREE.Mesh(tileGeo, goalMat); // dark until activated
          goalTile.position.set(obj.position.x, obj.position.y/3-TILE_HEIGHT/2, obj.position.z);
          scene.add(goalTile); tiles.push(goalTile);
          GOAL_POS = new THREE.Vector3(obj.position.x, obj.position.y/3, obj.position.z);
          goalActive = false;
        } else if (obj.type === "lift") {
          const l = new Lift(obj.from.x, obj.from.y, obj.from.z, obj.to.x, obj.to.y, obj.to.z);
          lifts.push(l);
        } else if (obj.type === "teleporter") {
          const t = new Teleporter(obj.entry1, obj.entry2);
          teleporters.push(t);
        } else if (obj.type === "bonuscrystall") {
          obj.position = obj.position || { x: 0, y: 0, z: 0 };
          const c = new BonusCrystall(obj.position);
          crystals.push(c);
          crystalsRemaining++;
        } else if (obj.type === "stair") {
          const dirMap = {
            "right": new THREE.Vector3(1, 0, 0),
            "left":  new THREE.Vector3(-1, 0, 0),
            "forward": new THREE.Vector3(0, 0, 1),
            "back": new THREE.Vector3(0, 0, -1)
          };
          const dir = dirMap[obj.direction] || new THREE.Vector3(1,0,0);
          const steps = parseInt(obj.count) || 1;
          for (let i = 0; i < steps; i++) {
            const t = new THREE.Mesh(tileGeo, tileMat);
            const pos = new THREE.Vector3(
              obj.position.x + dir.x * i,
              (obj.position.y + i) * 1/3,
              obj.position.z + dir.z * i
            );
            t.position.set(pos.x, pos.y - TILE_HEIGHT/2, pos.z);
            scene.add(t);
            tiles.push(t);
          }
        } else if (obj.type === "falsefloor") {
          const f = new FalseFloor(obj.position);
          falseFloors.push(f);
          tiles.push(f.mesh); // still counts as a tile initially
        } else {
          if (obj.position) {
            const t = new THREE.Mesh(tileGeo, tileMat);
            t.position.set(obj.position.x, obj.position.y/3-TILE_HEIGHT/2, obj.position.z);
            scene.add(t); tiles.push(t);
          }
        }
      });

      resetGame();
    }

    // ------------ HUD & game state ------------
    const hud  = document.getElementById('hud');
    const menu = document.getElementById('menu');

    let ballPos = new THREE.Vector3();
    let moves = 0, startTime = 0, timerId;
    let bestMoves = null, bestTime = null;

    let velocityY = 0, falling = false, isMoving = false;
    let moveFrom = new THREE.Vector3(), moveTo = new THREE.Vector3();
    let moveStartTime = 0;
    let ridingLift = null;

    let dropStartY = null, dropStartTime = null;
    let landStartY = null, landTargetY = null, landStartTime = null;

    let gameRunning = false;
    let currentLevel = 0;

    function updateHUD() {
      const t = Math.max(0, Math.floor((Date.now() - startTime) / 1000));
      hud.innerHTML = `Moves: ${moves} | Time: ${t}s<br>Best Moves: ${bestMoves ?? '-'} | Best Time: ${bestTime ?? '-'}`;
    }

    // ------------ Direction memory (tank-style) ------------
    // Order: 0:+X (east), 1:+Z (south), 2:-X (west), 3:-Z (north)
    const DIRS = [
      new THREE.Vector3(1,0,0),
      new THREE.Vector3(0,0,1),
      new THREE.Vector3(-1,0,0),
      new THREE.Vector3(0,0,-1)
    ];
    const YAW_FROM_INDEX = [0, Math.PI/2, Math.PI, -Math.PI/2];
    let dirIndex = 0; // start facing +X

    function updateCameraBehind() {
      // Camera yaw should be opposite to the facing direction, so it looks at the ball from behind.
      //camYawTarget = YAW_FROM_INDEX[dirIndex] + Math.PI;
      // Keep pitch and distance as-is (or you can uncomment below to keep them steady)
      // camPitchTarget = DEFAULT_CAM.pitch;
      // camDistTarget = DEFAULT_CAM.dist;
      let desiredYaw = YAW_FROM_INDEX[dirIndex] + Math.PI;

      // Normalize to [-PI, PI]
      desiredYaw = Math.atan2(Math.sin(desiredYaw), Math.cos(desiredYaw));

      // Adjust target so the rotation is always the shortest way
      let delta = desiredYaw - camYaw;
      delta = Math.atan2(Math.sin(delta), Math.cos(delta)); // wrap to [-PI, PI]

      camYawTarget = camYaw + delta;
      camPitchTarget = DEFAULT_CAM.pitch;
      camDistTarget = DEFAULT_CAM.dist;
    }

    function resetGame() {
      ballPos.copy(START_POS);
      ball.position.copy(ballPos);
      ball.rotation.set(0,0,0);
      velocityY = 0; falling = false; isMoving = false; moves = 0;
      dropStartY = null; landStartY = null;
      lifts.forEach(l => l.reset());
      gameRunning = false;
      startTime = Date.now();
      // Reset facing and camera
      dirIndex = 0;
      updateCameraBehind();
      camYaw = camYawTarget; // snap at reset
      camPitch = DEFAULT_CAM.pitch;
      camDist = DEFAULT_CAM.dist;
      updateHUD();
    }

    function loseGame() {
      clearInterval(timerId);
      isMoving = false;
      falling = false;
      menu.style.display = 'flex';
      menu.innerHTML = `<h1>You Fell!</h1><button data-action="restart">Restart Level</button>`;
    }

    function winGame() {
      clearInterval(timerId);
      const duration = Math.floor((Date.now() - startTime) / 1000);
      if (!bestTime || duration < bestTime) bestTime = duration;
      if (!bestMoves || moves < bestMoves) bestMoves = moves;
      localStorage.setItem('bestTime', bestTime);
      localStorage.setItem('bestMoves', bestMoves);
      currentLevel++;
      if (currentLevel < levels.length) {
        startLevel(currentLevel);
      } else {
        menu.style.display = 'flex';
        menu.innerHTML = `<h1>You Win All Levels!</h1><button data-action="restart">Restart Last Level</button>`;
        currentLevel = levels.length - 1;
      }
    }

    function startLevel(index) {
      loadLevel(index);
      clearInterval(timerId);
      timerId = setInterval(updateHUD, 1000);
      setTimeout(() => { gameRunning = true; }, 2000);
    }

    function restartLevel() { startLevel(currentLevel); }

    menu.addEventListener('click', (e) => {
      const btn = e.target.closest('button');
      if (!btn) return;
      const action = btn.getAttribute('data-action');
      if (action === 'start') {
        e.preventDefault();
        menu.style.display = 'none';
        currentLevel = 0;
        startLevel(currentLevel);
      } else if (action === 'restart') {
        e.preventDefault();
        menu.style.display = 'none';
        startLevel(currentLevel);
      }
    });

    // ------------ Camera (smoothed) ------------
    let camYaw = DEFAULT_CAM.yaw;
    let camPitch = DEFAULT_CAM.pitch;
    let camYawTarget = YAW_FROM_INDEX[dirIndex] + Math.PI;
    let camPitchTarget = camPitch;
    let camDist = DEFAULT_CAM.dist;
    let camDistTarget = camDist;

    // ------------ Input handling ------------
    window.addEventListener('keydown', (e) => {
      if (!['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)) return;
      e.preventDefault();
      if (isMoving || falling) return;
      ridingLift = null; dropStartY = null; landStartY = null;

      // Rotation-only keys change facing & camera; movement happens on ArrowUp
      if (e.key === 'ArrowLeft') {
        dirIndex = (dirIndex + 3) % 4;     // +90°
      }
      if (e.key === 'ArrowRight') {
        dirIndex = (dirIndex + 1) % 4;     // -90°
      }
      if (e.key === 'ArrowDown' && !isMoving && !falling) {
        dirIndex = (dirIndex + 2) % 4;     // 180°
      }

      // ArrowUp moves forward in the stored direction
      const dir = DIRS[dirIndex].clone();
      moveFrom.copy(ballPos);
      moveTo.copy(ballPos).add(dir);

      // If target tile is higher (stairs) lift to its height
      if (moveFrom && moveTo && !falling) {
        for (const upperTile of tiles) {
          if (
            Math.abs(upperTile.position.x - ballPos.x) < 0.1 &&
            Math.abs(upperTile.position.z - ballPos.z) < 0.1
          ) {
            const expectedY = upperTile.position.y + BALL_RADIUS;
            const diff = expectedY - ballPos.y;
            // only snap up if close enough and small step (<= 1.5 units)
            if (diff > 0.05 && diff <= 1.5) {
              ballPos.y = expectedY;
            }
          }
        }
      }

      // Teleport if target has a teleporter
      for (const tele of teleporters) tele.checkTeleport(moveTo);

      // Ball roll axis
      window.__moveAxis = new THREE.Vector3(dir.z, 0, -dir.x).normalize();
      moveStartTime = performance.now();
      isMoving = true;
      moves++;

      // Keep camera behind the new direction while moving
      updateCameraBehind();
    });

    // Mouse look & wheel still allowed, but next key realigns the camera behind
    let dragging = false, lastX = 0, lastY = 0;
    window.addEventListener('mousedown', e => { dragging = true; lastX = e.clientX; lastY = e.clientY; });
    window.addEventListener('mouseup',   () => { dragging = false; });
    window.addEventListener('mousemove', e => {
      if (!dragging) return;
      const dx = e.clientX - lastX, dy = e.clientY - lastY;
      lastX = e.clientX; lastY = e.clientY;
      camYawTarget   += dx * 0.003;
      camPitchTarget += dy * 0.003;
      camPitchTarget = Math.max(-0.9, Math.min(0.9, camPitchTarget));
    });
    window.addEventListener('wheel', e => {
      camDistTarget += (e.deltaY > 0 ? 1 : -1) * 0.6;
      camDistTarget = Math.max(3, Math.min(12, camDistTarget));
    }, { passive: true });

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // ------------ Helpers ------------
    function hasFloorBelow(x, y, z) {
      return tiles.find(t => Math.abs(t.position.x - x) < 0.1 && ((y+1) > t.position.y) && Math.abs(t.position.z - z) < 0.1);
    }

    // ------------ Main loop ------------
    let lastTime = performance.now();
    function animate() {
      requestAnimationFrame(animate);
      const now = performance.now();
      const dt = now - lastTime;
      lastTime = now;

      if (gameRunning) { for (const l of lifts) l.update(dt); }

      if (isMoving && !falling) {
        const t = Math.min(1, (now - moveStartTime) / ( (0.5 / MOVE_SPEED) * 1000 ));
        ballPos.lerpVectors(moveFrom, moveTo, t);

        // Snap to lift if we move over it
        for (const lift of lifts) {
          if (Math.abs(lift.mesh.position.x - ballPos.x) < 0.1 &&
              Math.abs(lift.mesh.position.z - ballPos.z) < 0.1) {
            ballPos.set(lift.mesh.position.x, lift.mesh.position.y + BALL_RADIUS, lift.mesh.position.z);
            ridingLift = lift;
          }
        }

        // Ball visual rolling
        const dist = TILE_SIZE * t;
        const angle = dist / BALL_RADIUS;
        ball.rotation.set(0,0,0);
        ball.rotateOnWorldAxis(window.__moveAxis || new THREE.Vector3(0,0,0), angle);

        if (t >= 1) {
          isMoving = false;
          ballPos.copy(moveTo);
          console.log(`483 Ball moved to ${ballPos.x}, ${ballPos.y}, ${ballPos.z}`);

          // Update false floors
          for (let i = falseFloors.length - 1; i >= 0; i--) {
            falseFloors[i].update(ballPos);
            falseFloors[i].animate(); // 🔥 cracks / shakes
            if (falseFloors[i].checkRemove()) {
              falseFloors.splice(i, 1); // remove from array
            }
          }

          // collect crystals
          for (const c of crystals) c.checkCollect(ballPos);

          ridingLift = null;
          for (const lift of lifts) {
            if (Math.abs(lift.mesh.position.x - ballPos.x) < 0.1 &&
                Math.abs(lift.mesh.position.z - ballPos.z) < 0.1) {
              ridingLift = lift;
              dropStartY = null;
              landStartY = ballPos.y;
              landTargetY = lift.mesh.position.y + BALL_RADIUS;
              landStartTime = performance.now();
              break;
            }
          }
          if (!ridingLift) {
            // Check if we can drop onto a floor tile, from upwards lift
            const tx = Math.round(ballPos.x), ty = Math.round(ballPos.y), tz = Math.round(ballPos.z);
            const belowTile = hasFloorBelow(tx, ty, tz);
            if (belowTile) {
              ballPos.x = tx; ballPos.z = tz;
              dropStartY = belowTile.position.y + BALL_RADIUS;
              dropStartTime = performance.now();
              falling = false;
            } else {
              falling = true; velocityY = 0;
            }
          }
          if (goalActive && ballPos.distanceTo(GOAL_POS) < 0.5) {
            winGame();
          }
        }
      }

      if (falling) {
        velocityY -= 0.015;
        ballPos.y += velocityY;
        if (ballPos.y < -5) loseGame();
      } else if (!isMoving) {
        if (ridingLift) {
          if (landStartY !== null) {
            const elapsed = performance.now() - landStartTime;
            const t = Math.min(1, elapsed / LAND_DURATION);
            ballPos.y = landStartY + (landTargetY - landStartY) * t;
            ballPos.x = ridingLift.mesh.position.x;
            ballPos.z = ridingLift.mesh.position.z;
            if (t >= 1) landStartY = null;
          } else {
            ballPos.set(ridingLift.mesh.position.x,
                        ridingLift.mesh.position.y + BALL_RADIUS,
                        ridingLift.mesh.position.z);
          }
          dropStartY = null;
        } else {
          if (dropStartY === null) { dropStartY = ballPos.y + BALL_RADIUS; dropStartTime = performance.now(); }
          const elapsed = performance.now() - dropStartTime;
          const t = Math.min(1, elapsed / DROP_DURATION);
          ballPos.y = dropStartY;
          ballPos.x = Math.round(ballPos.x);
          ballPos.z = Math.round(ballPos.z);
        }
      }

      // Apply camera smoothing
      camYaw += (camYawTarget - camYaw) * CAM_SMOOTH;
      camPitch += (camPitchTarget - camPitch) * CAM_SMOOTH;
      camDist += (camDistTarget - camDist) * CAM_SMOOTH;
      const cx = ballPos.x + Math.cos(camYaw) * Math.cos(camPitch) * camDist;
      const cy = ballPos.y + Math.sin(camPitch) * camDist + 1;
      const cz = ballPos.z + Math.sin(camYaw) * Math.cos(camPitch) * camDist;
      camera.position.set(cx, cy, cz);
      camera.lookAt(ballPos.x, ballPos.y, ballPos.z);

      ball.position.copy(ballPos);
      renderer.render(scene, camera);
    }
    animate();


    // Controls

    const controlDiv = document.getElementById("control");
    if (!controlDiv) return;
  
    controlDiv.innerHTML = `
      Theme:
      <select id="themeSelect">
        <option value="">Select Theme</option>
        <option value="desert">Desert</option>
        <option value="forest">Forest</option>
        <option value="rocks">Rocks</option>
      </select>
      Level:
      <select id="levelSelect"></select>
    `;
  
    const themeSelect = document.getElementById("themeSelect");
    const levelSelect = document.getElementById("levelSelect");
  
    // Repopulate level dropdown
    function refreshLevelSelect() {
      if (!levels) return;
      levelSelect.innerHTML = "";
      levels.forEach((lvl, i) => {
        const opt = document.createElement("option");
        opt.value = i;
        opt.textContent = `Level ${i+1}`;
        if (i === currentLevel) opt.selected = true;
        levelSelect.appendChild(opt);
      });
    }
  
    // Handle theme change
    themeSelect.addEventListener("change", async () => {
      const theme = themeSelect.value;
      try {
        const res = await fetch(`levels/${theme}_detailed.json`);
        const json = await res.json();
        levels.length = 0;
        json.forEach(l => levels.push(l));
        currentLevel = 0;
        refreshLevelSelect();
        startLevel(currentLevel);
      } catch (err) {
        console.error("Failed to load theme:", err);
      }
    });
  
    // Handle level change
    levelSelect.addEventListener("change", () => {
      currentLevel = parseInt(levelSelect.value, 10);
      startLevel(currentLevel);
    });
  
    // Initialize
    refreshLevelSelect();

  })();
  </script>
</body>
</html>
